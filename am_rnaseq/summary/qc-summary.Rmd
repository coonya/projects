---
output:
  html_document:
    code_folding: hide
    fig_height: 6
    number_sections: yes
    toc: yes
    toc_depth: 6
    toc_float: yes
title: "Marneros - Knockout RNAseq Analysis"
bibliography: references.bib
author: "John N Hutchinson"
---

[R]: https://www.r-project.org
[RStudio]: https://www.rstudio.com


[bcbio-rnaseq]: https://github.com/roryk/bcbio.rnaseq
[bcbio]: https://github.com/chapmanb/bcbio-nextgen
[DESeq2]: https://bioconductor.org/packages/release/bioc/html/DESeq2.html
[salmon]: https://combine-lab.github.io/salmon/
[tximport]: https://bioconductor.org/packages/release/bioc/html/tximport.html
[Bioconductor]: https://bioconductor.org
[Ensembl]: http://useast.ensembl.org/Mus_musculus/Info/Index
[Corum]: http://mips.helmholtz-muenchen.de/corum/
[REViGO]: http://revigo.irb.hr/
[gprofileR]: http://biit.cs.ut.ee/gprofiler/
[`Human Phenotype Ontology`]: https://human-phenotype-ontology.github.io/

```{r setup1, echo=FALSE}
# Setup report details
clientname="Alex Marneros"
clientemail="amarneros@mgh.harvard.edu"
lablocation="MGH" 
analystname="John Hutchinson"
analystemail="jhutchin@hsph.harvard.edu"
```

> RNA-Seq analysis for `r clientname` (`r clientemail`) at `r lablocation`. Contact `r analystname` (`r analystemail`) for additional details. 
> This document was generated on `r date()` using [R][] and [RStudio][]
 
```{r setup2, echo=FALSE}
knitr::opts_chunk$set(tidy=TRUE, highlight=TRUE, dev="png",
               cache=TRUE, highlight=TRUE, autodep=TRUE, warning=FALSE, error=FALSE,
               message=FALSE, prompt=TRUE, comment='', fig.cap='')
```

# Overview

Fastq files were processed in [bcbio][] and pseudo-count data generated by [salmon][]. Various RNAseq metrics were summarized with [bcbio-rnaseq][]. 

> The project has 8 samples, 4 controls and 4 cell specific Kcnd1 knockouts.

# Quality Control

Here I do some basic QC to see if the data looks good and if whether any samples look like they have issues.

```{r load-libraries, echo=FALSE}
check_install = function(packages) {
   not_installed = setdiff(packages, rownames(installed.packages()))
   if(length(not_installed) > 0) {
      write(paste("The libraries", not_installed, "are not installed, aborting.",
                   sep=" "), stderr())
      stop()
   }
}
packages = c("ggplot2", "reshape", "gplots", "edgeR", "CHBUtils", "pheatmap","DESeq2", "tximport", "DT", "DEGreport", "dplyr", "janitor", "rio", "rdrop2", "gridExtra", "gProfileR", "clusterProfiler", 'org.Mm.eg.db',"knitr", "plotly")
check_install(packages)
installed = lapply(packages, library, character.only = TRUE)
```

```{r qc-setup, results='hide'}
dropboxfiledir <- "/HBC Team Folder(1)/Consults/alex_marneros/am_rnaseq/files"
pvalcutoff=0.05
lfccutoff=1
minGSS=1
maxGSS=1e6


project_summary = "/Volumes/orch/PIs/alex_marneros/am_rnaseq/bcbio/final/2017-04-22_bcbio/project-summary.csv"
counts_file = "/Volumes/orch/PIs/alex_marneros/am_rnaseq/bcbio/final/2017-04-22_bcbio/combined.counts"
tx2genes_file = "/Volumes/orch/PIs/alex_marneros/am_rnaseq/bcbio/final/2017-04-22_bcbio/tx2gene.csv"
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442","#0072B2", "#D55E00", "#CC79A7")
summarydata = read.table(project_summary, header=TRUE, sep=",")
summarydata = summarydata[,colSums(is.na(summarydata)) < nrow(summarydata)]
# handle newer bcbio-nextgen runs that use description as the key
if("description" %in% colnames(summarydata)) {
  rownames(summarydata) = summarydata$description
  summarydata$Name = rownames(summarydata)
  summarydata$description = NULL
} else {
  rownames(summarydata) = summarydata$Name
  # summarydata$Name = NULL
}
summarydata = summarydata[order(rownames(summarydata)),]
summarydata <- clean_names(summarydata)



if (file.exists(tx2genes_file)) {
  sf_files = list.files(file.path(dirname(tx2genes_file), "../../"), pattern="quant.sf", recursive=TRUE, full.names=TRUE)
  sf_files <- sf_files[!grepl("MAi_", sf_files)]
  if(length(sf_files) > 0) {
    sf_files = sf_files[order(sf_files)]
    names(sf_files) = rownames(summarydata)
    tx2gene = read.table(tx2genes_file, sep=",", row.names=NULL, header=FALSE)
    txi.salmon = tximport(sf_files, type="salmon", tx2gene=tx2gene,
             importer=readr::read_tsv, countsFromAbundance="lengthScaledTPM")
    counts = round(data.frame(txi.salmon$counts, check.names=FALSE))
} else {
  counts = read.table(counts_file, header=TRUE, row.names="id", check.names=FALSE)
}}
counts = counts[, order(colnames(counts)), drop=FALSE]


tempoutfile <-file.path(tempdir(), "rawcounts.csv")
rio::export(counts, file=tempoutfile)
drop_upload(file=tempoutfile, dest=dropboxfiledir, overwrite=TRUE)
rawcounts_shared_file <-  drop_share(file.path(dropboxfiledir, "rawcounts.csv"))$url

# this is a list of all non user-supplied metadata columns that could appear
known_columns = c("rrna_rate", "duplication_rate_of_mapped", "mapped_reads", "mapped_paired_reads", "quality_format", "intergenic_rate", "sequence_length", "exonic_rate", "total_reads", "percentgc", "rrna", "duplicates", "name", "sequences_flagged_as_poor_quality", "average_insert_size", "intronic_rate", "x5_3_bias", "fragment_length_mean","x_gc", "mapped_reads_pct")
summarydata[,"mapped_reads_pct"] <- (summarydata$mapped_reads/summarydata$total_reads)*100

metadata = summarydata[, !colnames(summarydata) %in% known_columns, drop=FALSE]
metadata = metadata[, colSums(is.na(metadata)) < nrow(metadata), drop=FALSE]
metadata <- metadata[, c("replicate", "genotype")] 
```


```{r functions, echo=FALSE}
#pca-plotter
pca_plot = function(comps, nc1, nc2, colorby, shapeby) {
   c1str = paste0("PC", nc1)
   c2str = paste0("PC", nc2)
  if(!(c1str %in% colnames(comps) && c2str %in% colnames(comps))) {
    warning("Higher order components not found, skipping plotting.")
    return(NA)
  }
  ggplot(comps, aes_string(c1str, c2str, color=colorby, shape=shapeby)) +
    geom_point(size=5) + theme_bw() +
    xlab(paste0(c1str, ": ", round(pc$percentVar[nc1] * 100), "% variance")) +
    ylab(paste0(c2str, ": ", round(pc$percentVar[nc2] * 100), "% variance"))
  }

#sanitize-datatable
sanitize_datatable = function(df, ...) {
 # remove dashes which cause wrapping
 DT::datatable(df, ..., rownames=gsub("-", "_", rownames(df)),
                   colnames=gsub("-", "_", colnames(df)))
}

#heatmap-function
get_heatmap_fn = function(summarydata) {
    # return the pheatmap function with or without metadata
    if(ncol(metadata) == 0) {
       return(pheatmap)
    }
    else {
    # rownames(metadata) = summarydata$Name
    heatmap_fn = function(data, ...) {
        pheatmap(data, annotation=metadata, clustering_method = "ward.D2",
        clustering_distance_cols = "correlation", ...)
    }
    return(heatmap_fn)
}}
heatmap_fn = get_heatmap_fn(summarydata)

annotate_df2 <- function (df, df_ensemblid_header, biomart_ensembl_dataset, biomart_ensemblid_filter, biomart_genesymbol_attribute, biomart_host) {
  require(biomaRt)
  ensembl = useMart("ENSEMBL_MART_ENSEMBL", dataset = biomart_ensembl_dataset, host = biomart_host)
  annot.df = getBM(attributes = c(biomart_ensemblid_filter, biomart_genesymbol_attribute, "description"), filters = c(biomart_ensemblid_filter), values = as.character(df[, df_ensemblid_header]), mart = ensembl)
  m = merge(df, annot.df, by.x = df_ensemblid_header, by.y = biomart_ensemblid_filter,all.x = T)
  return(m)
}

subset_tximport = function(txi, rows, columns) {
  txi$counts = txi$counts[rows, columns]
  txi$abundance = txi$abundance[rows, columns]
  txi$length = txi$length[rows, columns]
  return(txi)
}
DESeqDataSetFromTximport <- function(txi, colData, design, ...) {
  counts <- round(txi$counts)
  mode(counts) <- "integer"
  dds <- DESeqDataSetFromMatrix(countData=counts, colData=colData, design=design, ...)
  stopifnot(txi$countsFromAbundance %in% c("no","scaledTPM","lengthScaledTPM"))
  if (txi$countsFromAbundance %in% c("scaledTPM","lengthScaledTPM")) {
    message("using length scaled TPM counts from tximport")
  } else {
    message("using counts and average transcript lengths from tximport")
    lengths <- txi$length
    dimnames(lengths) <- dimnames(dds)
    assays(dds)[["avgTxLength"]] <- lengths
  }
  return(dds)
}

```

```{r set-random-seed}
# set seed for reproducibility
set.seed(1454944673)
```

## Sample metadata
```{r summary-table, echo=FALSE, cache=FALSE}
sanitize_datatable(summarydata, style='bootstrap')
```


## Quality control metrics

```{r qualimap-run}
qualimap_run = "exonic_rate" %in% colnames(summarydata)
do_quality = "total_reads" %in% colnames(summarydata)
```

### Mapped reads

The number of mapped reads is a bit low (we'd prefer to see >20 million reads mapped) but still perfectly within an acceptable range.

```{r mapped-plot, eval=do_quality}
ggplot(summarydata, aes(x=name, y=mapped_reads, fill=genotype)) +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) +
    geom_bar(stat="identity") +
    ylab("mapped reads") + xlab("")
```

### Genomic mapping rate

The genomic mapping rate represents the percentage of reads mapping to the reference genome. Low mapping rates are indicative of sample contamination, poor sequencing quality or other artifacts. We don't see that here. The mapping rate is acceptable (>90%) for all samples:

```{r mapping-rate-plot, eval=do_quality}
mapping_string = "mapped_reads_pct"
ggplot(summarydata, aes_string(x="name", y=mapping_string, fill="genotype")) +
    geom_bar(stat="identity") +
    ylab("mapping rate") + xlab("") +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90))
```

### Number of genes detected

The number of genes detected for each sample is good with over 20,000 genes detected for all samples. This is what we expect for the mouse genome:

```{r genes-detected-plot}
dd = data.frame(Name=colnames(counts), genes_detected = colSums(counts > 0), genotype=summarydata$genotype)
ggplot(dd, aes(x=Name, y=genes_detected, fill=genotype)) +
    geom_bar(stat="identity") +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) +
    ylab("genes detected") + xlab("")
```

### Gene detection saturation

Gene detection saturation was nearly reached for the majority of the samples, which means that most of the samples were able to detect the majority of expressed genes. This is good to see. There is no linear trend here of genes detected increasing with the number of reads mapped ine the samples, which may actually indicate sample overloading.

```{r saturation-plot, eval=do_quality}
col_mapped =  "mapped_reads"
dd = data.frame(mapped=summarydata[,col_mapped], genes_detected = colSums(counts > 0), genotype=summarydata$genotype)
ggplot(dd, aes(x=mapped, y=genes_detected, color=genotype)) +
    geom_point(size=5) +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) +
    ylab("genes detected") + xlab("reads mapped")
```

### Exonic mapping rate

The exonic mapping rates are good, with over 60% of total reads mapping to exons.

```{r exonic-mapping-plot, eval="exonic_rate" %in% colnames(summarydata)}
ggplot(summarydata, aes(x=name, y=exonic_rate, fill=genotype)) +
    geom_bar(stat="identity") +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) +
    ylab("exonic mapping rate") + xlab("")
```

### rRNA mapping rate

All samples are more than within an acceptable range (<10%).

```{r check-rRNA-eval}
eval_rRNA = "rrna_rate" %in% colnames(summarydata) & !sum(is.na(summarydata$rrna_rate)) == nrow(summarydata)
```
```{r rRNA-rate-plot, eval=eval_rRNA & do_quality}
ggplot(summarydata, aes(x=name, y=rrna_rate, fill=genotype)) +
    geom_bar(stat="identity") +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) +
    ylab("rRNA rate") + xlab("")
```

These values are fine. Anything below 10%  (0.1 on the y-axis) is reasonable, the KO_2 sample is relatively higher but in absolute terms, but still within an acceptable range. We can see later if this affects it's clustering and remove any ribosomal reads if necessary.

### 5'->3' bias

There is some bias, but it is fairly consistent among samples.

```{r 53bias, eval="x5_3_bias" %in% colnames(summarydata) & do_quality}
ggplot(summarydata, aes(x=name, y=x5_3_bias, fill=genotype)) +
    geom_bar(stat="identity") +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) +
    ylab("5'->3' bias") + xlab("")
```

### Boxplot of log10 counts per gene

Generally, we expect similar count spreads for all genes between samples unless the library sizes or total RNA expression are different. The count spreads look good for all samples:

```{r boxplot-raw}

melted = melt(counts)
colnames(melted) = c("sample", "count")
melted$sample = factor(melted$sample)
melted = melted[order(melted$sample),]
melted$count = log(melted$count)
ggplot(melted, aes(x=sample, y=count)) + geom_boxplot() +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) + xlab("")
```

### Boxplot of log10 TMM-normalized counts per gene

Trimmed mean of M-values (TMM) normalization is described 
[here](http://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-3-r25) [@Robinson2010]


Generally, we expect similar count spreads for all genes between samples unless the total expressed RNA per sample is different. 

```{r boxplot-normalized}
y = DGEList(counts=counts)
y = calcNormFactors(y)
normalized_counts = cpm(y, normalized.lib.sizes=TRUE)
melted = melt(normalized_counts)
colnames(melted) = c("gene", "sample", "count")
melted$sample = factor(melted$sample)
melted = melted[order(melted$sample),]
melted$count = log(melted$count)
ggplot(melted, aes(x=sample, y=count)) + geom_boxplot() +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) + xlab("")
```

### Density of normalized counts

```{r density-normalized}
ggplot(melted, aes(x=count, group=sample)) +
    geom_density() +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) + xlab("")
```


## Sample Similarity Analyses (Unsupervised clustering)

### Correlation heatmap of TMM-normalized counts {.tabset}

We are seeing at least partial clustering by genotype, which is good. 

### Correlation (Spearman)
```{r spearman-heatmap-normalized, eval=ncol(counts) > 1}
heatmap_fn(cor(normalized_counts, method="spearman"))
```

### PCA plots {.tabset}

For a better explanation of Principal Component Analysis (PCA) see [here](http://setosa.io/ev/principal-component-analysis/). Essentially, PCA is a method of projecting the variation contained within multidimensional data onto a 2 dimensional plot. In these plots, if samples cluster, then they are similar. As this is done in an unbiased manner without knowledge of smaple classes, it is good if sample classes cluster together which means that the variation in the data corresponds with the sample classes. If the sample classes do not cluster, then some other source of variation is driving the clustering.


For RNA-seq count data, variance increases with the mean. Logarithmic transformation of normalized count values with a small pseudocount will account for large variations seen between the highest expressing genes so that these genes won't dominate the PCA plots. However, due to the strong noise among low count values due to Poisson, the general log<sub>2</sub> transformation will amplify this noise, and show the low count genes will dominate the PCA plots. For high counts, this gives similar results as log<sub>2</sub>, but for low counts, values are shrunken towards the genes' average across samples. These adjustments are accomnplished using the rlog transformation used by the [][DESeq2] [@Love2014] package.

```{r pca, eval=ncol(counts) > 1}
dds = DESeqDataSetFromMatrix(countData=counts, colData=summarydata, design=~genotype)
vst = varianceStabilizingTransformation(dds)
pca_loadings = function(object, ntop=500) {
  rv <- matrixStats::rowVars(assay(object))
  select <- order(rv, decreasing = TRUE)[seq_len(min(ntop,
      length(rv)))]
  pca <- prcomp(t(assay(object)[select, ]))
  percentVar <- pca$sdev^2/sum(pca$sdev^2)
  names(percentVar) = colnames(pca$x)
  pca$percentVar = percentVar
  return(pca)}
pc = pca_loadings(vst)
comps = data.frame(pc$x)
comps$name = rownames(comps)
library(dplyr)
comps = comps %>% left_join(summarydata, by=c("name"="name"))
colorby = "genotype"
comps$replicate <- as.character(comps$replicate)
shapeby = "replicate"
```

#### PC1 vs. PC2

The samples are not clustering particularly well by genotype. 

```{r PC1-PC2}
pca_plot(comps, 1, 2, colorby, shapeby=shapeby)+scale_shape_manual(values=c(15:18)) 
```

#### PC3 vs. PC4
```{r PC3-PC4}
pca_plot(comps, 3, 4, colorby, shapeby)+scale_shape_manual(values=c(15:18)) 
```

#### PC5 vs. PC6
```{r PC5-PC6}
pca_plot(comps, 5, 6, colorby, shapeby)+scale_shape_manual(values=c(15:18)) 
```

#### Variance explained by component
```{r component-loadings}
ggplot(data.frame(component=reorder(names(pc$percentVar), -pc$percentVar),
                  percent_var=pc$percentVar),
       aes(component, percent_var)) + geom_bar(stat='identity') +
  ylab("percent of total variation") + xlab("") + theme_bw()
```
 
# TPM matrix

- we recommend reporting these instead of RPKM values, see [this post](http://www.rna-seqblog.com/rpkm-fpkm-and-tpm-clearly-explained/) for why.

```{r write-tpm-matrix, results="hide"}
tpm = txi.salmon$abundance %>%
  as.data.frame() %>%
  tibble::rownames_to_column()
names(tpm)[1] <- "ensemblid"

tpm <- annotate_df2(df=tpm, df_ensemblid_header = "ensemblid", biomart_ensembl_dataset= 'mmusculus_gene_ensembl',biomart_ensemblid_filter = "ensembl_gene_id", biomart_genesymbol_attribute = 'mgi_symbol', biomart_host="useast.ensembl.org" )

tempoutfile <-file.path(tempdir(), "tpm.csv")
rio::export(tpm, file=tempoutfile)
drop_upload(file=tempoutfile, dest=dropboxfiledir, overwrite=TRUE)
tpm_shared_file <-  drop_share(file.path(dropboxfiledir, "tpm.csv"))$url
```

**[TPM matrix](`r tpm_shared_file`)**

```{r deseq2-tximport-helper-functions}
# snagged from development version of DESeq
DESeqDataSetFromTximport <- function(txi, colData, design, ...)
{
  counts <- round(txi$counts)
  mode(counts) <- "integer"
  dds <- DESeqDataSetFromMatrix(countData=counts, colData=colData, design=design, ...)
  stopifnot(txi$countsFromAbundance %in% c("no","scaledTPM","lengthScaledTPM"))
  if (txi$countsFromAbundance %in% c("scaledTPM","lengthScaledTPM")) {
    message("using length scaled TPM counts from tximport")
  } else {
    message("using counts and average transcript lengths from tximport")
    lengths <- txi$length
    dimnames(lengths) <- dimnames(dds)
    assays(dds)[["avgTxLength"]] <- lengths
  }
  return(dds)
}

subset_tximport = function(txi, rows, columns) {
    txi$counts = txi$counts[rows, columns]
    txi$abundance = txi$abundance[rows, columns]
    txi$length = txi$length[rows, columns]
    return(txi)
}
```

```{r deseq2-helper-functions}
deseq2resids = function(dds) {
  # calculate residuals for a deseq2 fit
  fitted = t(t(assays(dds)[["mu"]]) / sizeFactors(dds))
  return(counts(dds, normalized=TRUE) - fitted)
}
```

```{r de-setup}
library(DEGreport)
library(vsn)
design = ~genotype
condition = "genotype"
contrast_id = "knockout_vs_wildtype"
```

# Differential expression and Functional Annotation

Here I do differential expression analyses of the data, looking for genes with significant changes in expression between the knockout and wildtype mice.


Differential gene expression (DGE) analysis of count data from [salmon][] [@Patro2015] was performed with the [Bioconductor][] [R][] package [DESeq2][] [@Love2014]. Counts were fit to a negative binomial model, and dispersion estimates were generated using the mean values from the maximum likelihood estimate of log2 fold changes, optimizing the Cox-Reid adjusted profile likelihood.




## Setup

Several quality metrics were first assessed to normalize the data and explore the fit of the model, before differential expression analysis was performed. We observe that the modeling fit is good.

### Estimate size factors

```{r deseq2-expression-analysis, results='asis'}
counts <- counts[rowSums(counts>0)>1,]
if(exists("txi.salmon")) {
   txi.salmon = subset_tximport(txi.salmon, rownames(counts), colnames(counts))
   dds = DESeqDataSetFromTximport(txi.salmon, colData=summarydata, design=design)
} else {
  dds = DESeqDataSetFromMatrix(countData=counts,
      colData=summarydata, design = design  )
}
geoMeans = apply(counts, 1, function(row) if (all(row == 0)) 0 else
                 exp(mean(log(row[row != 0]))))
dds = estimateSizeFactors(dds, geoMeans=geoMeans)
dds = DESeq(dds, betaPrior=FALSE)


kable(as.data.frame(sizeFactors(dds)))
```

### Effect of variance stabilization

The plots below show the standard deviation of normalized counts (`normalized_counts`) using `log2()`, `rlog()`, and variance stabilizing (`vst()`) transformations by `rank(mean)`. The transformations greatly reduce the standard deviation, with `rlog` stabilizing the variance best across the mean. Therefore, we will use the `rlog` transformed counts for any downstream count visualizations.

```{r deseq-diagnostics, results="hide"}
notAllZero <- (rowSums(counts(dds))>0)
rld <- rlog(dds)
vsd <- varianceStabilizingTransformation(dds)
rlogMat <- assay(rld)
vstMat <- assay(vsd)


tempoutfile <-file.path(tempdir(), "rlog.csv")
rio::export(rlogMat, file=tempoutfile)
drop_upload(file=tempoutfile, dest=dropboxfiledir, overwrite=TRUE)
rlog_shared_file <-  drop_share(file.path(dropboxfiledir, "rlog.csv"))$url
```

```{r  deseq2-vstplots, fig.keep="last", fig.height=3}
p1 <- meanSdPlot(log2(counts(dds,normalized=TRUE)[notAllZero,] + 1))$gg + ggtitle("log") + theme(legend.position="bottom")
p2 <- meanSdPlot(assay(rld[notAllZero,]))$gg + ggtitle("rlog") + theme(legend.position="bottom")
p3 <- meanSdPlot(assay(vsd[notAllZero,]))$gg + ggtitle("vst") + theme(legend.position="bottom")
grid.arrange(p1,p2,p3, ncol=3)
```

rlog variance stabilization (which DESeq2 uses) looks to be working well.

### Dispersion estimates

The following plot shows the dispersion by mean of normalized counts. We expect the dispersion to decrease as the mean of normalized counts increases.

```{r dispersion-estimate}
plotDispEsts(dds)
```

## Knockout versus Wildtype Comparison

Numerator = Knockout  
Denominator = Wildtype  

Genes with a **postive log2 fold change higher in the knockout**.

Genes with a **negative log2 fold change are lower in the knockout**.


```{r deseq2compare}
res <- results(dds, contrast=c("genotype", "KO", "WT"))
res = res[order(res$padj),]
```

### Plots {.tabset}

#### MA-plots

```{r nicer-ma-plot}
plotMA = function(res, contrast_name=NULL) {
  res = data.frame(res)
  res = subset(res, !is.na(padj))
  p = ggplot(res, aes(baseMean, log2FoldChange, color=padj < 0.05)) +
    geom_point(size=0.8) +
    scale_x_log10(
      breaks = scales::trans_breaks("log10", function(x) 10^x),
      labels = scales::trans_format("log10", scales::math_format(10^.x))) +
    annotation_logticks(sides='b') +
    xlab("mean expression across all samples") +
    ylab(expression(log[2]*" fold change")) +
    scale_color_manual(values=c("black", "red", "green")) +
    guides(color=FALSE)
  if(!is.null(contrast_name)) {
    p = p +
      ggtitle(paste("MA-plot for contrast ", contrast_name))
  }
  return(p)
}
```

An MA plot compares transformed counts on `M` (log ratio) and `A` (mean average) scales. Genes found to be differentially expressed with an adjusted pvalue of less than `r pvalcutoff` are highlighted in red.

```{r DESeq-MAplot, results='asis'}
plotMA(res)
```

#### Volcano-plots

Volcano plots compare the p-value (here an Benhamini-Hochberg adjusted pvalue to account for the number of genes we tested) to the log2-fold change. In the first plot, areas highlighted in green show an adjusted pvlaue less than `r pvalcutoff` and a log2 fold change greater than `r lfccutoff` (in either direction). 
In the second plot, hovering over the point will show the data and gene name for that point, points in blue have an adjusted pvalue of less than 0.05 (no log2 fold change cutuff is highlighted). 

Here, postive fold changes are for genes which have higher expression in knockout samples than wildtype treated samples.

```{r DESeq-volcano}
stats = as.data.frame(res[,c(2,6)])
volcano_density_plot(stats, title="")


stats = as.data.frame(res[,c(2,6)]) %>%  row2colnames("ensemblid")
stats <- annotate_df2(df=stats, df_ensemblid_header = "ensemblid", biomart_ensembl_dataset= 'mmusculus_gene_ensembl',biomart_ensemblid_filter = "ensembl_gene_id", biomart_genesymbol_attribute = 'mgi_symbol', biomart_host="useast.ensembl.org" )
stats <- stats %>% tbl_df() %>% mutate(significant=ifelse(padj>pvalcutoff|is.na(padj), "NO", "YES"))
library(plotly)
p <- ggplot(stats, aes(x=log2FoldChange, y=-log10(padj), color=significant, text=mgi_symbol))+
  geom_point(alpha=0.6, size=2)+
  theme_bw()
p <- ggplotly(p) 
p
```

#### Pvalues-vs-Mean

This plot helps you tell if there is any relationship between the pvalues found and the mean expression level (there shouldn't be a strong bias)

```{r DEGreport-M}
degMean(res$pvalue, rlogMat) +
  theme_bw()
```

#### Pvalues-vs-Variation

This plot helps you tell if there is any relationship between the pvalues found and the variance (there shouldn't be a strong bias)

```{r DEGreport-V}
degVar(res$pvalue, rlogMat) +
  theme_bw()
```

### Differentially expressed genes

#### Table

Note that in general for NGS count data, there is a large variance associated with the log fold change estimates for genes with low read counts, and these weakly expressed genes would be identified as differentially expressed due solely to this variation. To account for this issue and reduce false positives for lowly expressed genes, DESeq2 shrinks the LFC estimates toward zero when the information for a gene is low, which could include:

- low counts
 - high dispersion values i.e. high variation in the gene's expression
 
This shrinkage of LFC estimates uses information from all genes to generate more accurate estimates. Specifically, the distribution of LFC estimates for all genes is used (as a prior) to shrink the LFC estimates of genes with little information or high dispersion toward more likely (lower) LFC estimates. 

**Therefore, the log fold change estimates included in these results are likely to be more conservative (and accurate) than those derived from directly calculating from normalized counts (such as those in the TPM matrix)**

False discovery rate was controlled by  (see [@Noble] for a description of the issue and solutions) by the Benjamini Hochberg proedcure [@Benjamini1995], allowing us to derive an FDR adjusted pvalue which has been corrected for the fact we ran multiple statistical tests.

__**Lowest adjusted p-value hits (padj<0.05) for Wildtype versus Knockout contrast**__


```{r DESeq-tables, echo=FALSE}
out_df = as.data.frame(res)
out_df$id = rownames(out_df)
out_df = out_df[, c("id", colnames(out_df)[colnames(out_df) != "id"])]

out_df <- annotate_df2(df=out_df, df_ensemblid_header = "id", biomart_ensembl_dataset= 'mmusculus_gene_ensembl',biomart_ensemblid_filter = "ensembl_gene_id", biomart_genesymbol_attribute = 'mgi_symbol', biomart_host="useast.ensembl.org" )

sig_genes = subset(out_df, padj < pvalcutoff)
sanitize_datatable(sig_genes, style='bootstrap')
```

```{r DESeq-output, results="hide"}
tempoutfile <-file.path(tempdir(), paste("stats_for", contrast_id, "xlsx", sep="."))
rio::export(out_df, file=tempoutfile)
drop_upload(file=tempoutfile, dest=dropboxfiledir, overwrite=TRUE)
assign(paste("stats_", contrast_id, sep=""), drop_share(file.path(dropboxfiledir, paste("stats_for", contrast_id, "xlsx", sep=".")))$url)
```

#### Heatmap

- here I've made a heatmap of up to a maximum of the 200 most significant DE genes, with , using the rlog variance stabilized data
- data is centered and scaled per row, to show the maximum variation per row

```{r DESeq-heatmap, fig.height=18, fig.width=8}
if(nrow(sig_genes)<200){
  len <- nrow(sig_genes)
} else {
  len=200
}

sig_genes.sub <- sig_genes[1:len,"id"]
# subset rlog transformed data to the significant genes of interest
sig_genes.sub.rlogmat <- rlogMat[sig_genes.sub,]
sig_genes.sub.rlogmat <- sig_genes.sub.rlogmat %>% row2colnames("ensemblid")

sig_genes.sub.rlogmat <- annotate_df2(df=sig_genes.sub.rlogmat, df_ensemblid_header = "ensemblid", biomart_ensembl_dataset= 'mmusculus_gene_ensembl',biomart_ensemblid_filter = "ensembl_gene_id", biomart_genesymbol_attribute = 'mgi_symbol', biomart_host="useast.ensembl.org" )


annots.sub <- summarydata[, c("genotype", "replicate", "researcher_sampleid")]
heatmap_data <- as.matrix(sig_genes.sub.rlogmat[, row.names(summarydata)])
class(heatmap_data) <- "numeric"
pheatmap(heatmap_data,
         annotation=annots.sub,
         clustering_distance_cols = "correlation",
         clustering_method = "ward.D2",
         main = "Differentially expressed genes",
         scale = "row",
         show_rownames = TRUE, 
         labels_row = sig_genes.sub.rlogmat$mgi_symbol, 
         fontsize_row = 8)


```


### Functional analysis
#### Overrepresentation Analysis
##### gProfiler & Revigo

Using the significant DE genes (padj < `r pvalcutoff`) identified, a list of statistically enriched gene ontology (GO), [`Human Phenotype Ontology`][] (HP) terms, and KEGG pathways (keg) was generated using the program [gprofileR][] [@Reimand2007].

A list including only the significant GO Biological Process (BP) terms was then used as input to [REViGO][] [@Supek2011], which collapsed redundant and semantically-related terms and output the most significantly enriched functional categories.

An Excel file of all significant GO/HP/keg terms and associated genes can be downloaded using the links in the [Downloads](#downloads) section.



```{r funct.gprofiler_revigo, results='asis'}
gene_list <- sig_genes$mgi_symbol

#gprofileR
gprofiler_results <- gprofiler(query = gene_list, organism = "mmusculus", ordered_query = F, 
                               exclude_iea = F, max_set_size = 0, correction_method = "fdr", 
                               hier_filtering = "none", domain_size = "annotated", custom_bg = "")

allterms <- gprofiler_results$term.id
GOs <- allterms[grep("GO:", allterms)]
pvals <- gprofiler_results$p.value[grep("GO:", allterms)]

gprofiler_results.simplified <- gprofiler_results[, c("term.id", "term.name", "domain", "p.value", "term.size", "query.size", "overlap.size", "intersection")]
names(gprofiler_results.simplified) <- c("term.id", "term.name",  "domain", "p.value","term.size", "query.size", "overlap.size", "assoc.gene.ids")


# Revigo BP
## Parameters to change
cutoff <- "0.7" #Allowed values: "0.90" "0.70" "0.50" "0.40" 
organism <- "Mus musculus" #Allowed values: See organism.list below
isPValue <- "yes" #Allowed values: "yes"  "no"
whatIsBetter <- "higher" #Allowed values: "higher" "lower" "absolute" "abs_log"
measure <- "SIMREL" #Allowed values: "RESNIK" "LIN" "SIMREL" "JIANG"
domain <- "BP"


#Do not change below
organism.list <- list(
"whole UniProt"=0, 
	"Homo sapiens"=9606,
	"Mus musculus"=10090,
	"Rattus norvegicus"=10116,
	"Bos taurus"=9913,
	"Gallus gallus"=9031,
	"Danio rerio"=7955,
	"Takifugu rubripes"=31033,
	"Xenopus laevis"=8355,
	"Drosophila melanogaster"=7227,
	"Caenorhabditis elegans"=6239,
	"Arabidopsis thaliana"=3702,
	"Oryza sativa"=39947,
	"Zea mays"=4577,
	"Saccharomyces cerevisiae"=4932,
	"Schizosaccharomyces pombe"=4896,
	"Dictyostelium discoideum"=44689,
	"Plasmodium falciparum"=5833,
	"Chlamydomonas reinhardtii"=3055,
	"Escherichia coli"=83333,
	"Bacillus subtilis"=1423,
	"Pseudomonas aeruginosa"=287,
	"Mycobacterium tuberculosis"=1773,
	"Mycoplasma genitalium"=2097,
	"Synechocystis sp."=1148
	)
organism.db <- as.character(organism.list[organism])

cat("**Biological Processes Domain**")

domain="BP"
mycommand=paste('revigo.pl -goterms', paste(GOs,collapse=","), '-gopvals', paste(pvals,collapse=","), '-cutoff', cutoff,  '-organism', organism.db, '-ispvalue', isPValue, '-whatisbetter', whatIsBetter, '-measure', measure, '-domain', domain,sep=" ")
mytempfile <- tempfile()
system2(command='perl', args=mycommand, stdout=mytempfile)
source(mytempfile)

cat("**Molecular Functions Domain**")

domain="MF"
mycommand=paste('revigo.pl -goterms', paste(GOs,collapse=","), '-gopvals', paste(pvals,collapse=","), '-cutoff', cutoff,  '-organism', organism.db, '-ispvalue', isPValue, '-whatisbetter', whatIsBetter, '-measure', measure, '-domain', domain,sep=" ")
mytempfile <- tempfile()
system2(command='perl', args=mycommand, stdout=mytempfile)
source(mytempfile)

cat("**Cellular Component Domain**")

domain="CC"
mycommand=paste('revigo.pl -goterms', paste(GOs,collapse=","), '-gopvals', paste(pvals,collapse=","), '-cutoff', cutoff,  '-organism', organism.db, '-ispvalue', isPValue, '-whatisbetter', whatIsBetter, '-measure', measure, '-domain', domain,sep=" ")
mytempfile <- tempfile()
system2(command='perl', args=mycommand, stdout=mytempfile)
source(mytempfile)

```

```{r funct.gprofiler_output, results="hide"}
tempoutfile <-file.path(tempdir(), paste("gprofiler_results_for", contrast_id, "xlsx", sep="."))
rio::export(gprofiler_results.simplified, file=tempoutfile)
drop_upload(file=tempoutfile, dest=dropboxfiledir, overwrite=TRUE)
assign(paste("gprofiler_results_for_", contrast_id, sep=""), drop_share(file.path(dropboxfiledir, paste("gprofiler_results_for", contrast_id, "xlsx", sep=".")))$url)
```



#### Gene set enrichment analysis 
Gene set enrichment analysis tools use ranked lists of genes (here ranked by log2FoldChanges) without using a threshold. This allows these gene set enrichment tools to use more information to identify enriched biological processes. The hypothesis of these methods is that although large changes in individual genes can have significant effects on pathways (and will be detected via the previous over-representation analysis methods), weaker but coordinated changes in sets of functionally related genes (i.e., pathways) can also have significant effects. Thus, rather than setting an arbitrary threshold to identify 'significant genes', all genes are considered in the analysis. The introduction to the original gene set enrichment analysis paper goes into more detail about some of the advantages of this approach [@Subramanian2005].

```{r funct.clusterprofiler_gsea_setup}
DEG_background <- data.frame(res)

mart <- useDataset("mmusculus_gene_ensembl",useMart('ENSEMBL_MART_ENSEMBL',host =  'useast.ensembl.org'))

entrez <- getBM(filters= "ensembl_gene_id",attributes= c("ensembl_gene_id", "entrezgene"),values= row.names(DEG_background), mart= mart)
DEG_background$ensembl_gene_id <- row.names(DEG_background)
entrez_results <- merge(DEG_background, entrez, by="ensembl_gene_id")
entrez_results <- subset(entrez_results, entrezgene != "NA")

all_genes <- as.character(entrez_results$entrezgene)

all_results_gsea <- entrez_results
all_results_gsea <- all_results_gsea[order(abs(all_results_gsea$log2FoldChange), decreasing = T), ]
foldchanges <- all_results_gsea$log2FoldChange
names(foldchanges) <- all_results_gsea$entrezgene

foldchanges <- sort(foldchanges, T)
```

##### Gene Ontology GSEA with clusterProfiler
Analysis was performed to identify any GO annotation (BP, MF or CC) (with at least `r minGSS` genes in them) that were significantly dysregulated (genes in pathway could be up- or down-regulated simultaneously). The significantly enriched categories of each type (BP, MF or CC) (padj. < `r pvalcutoff`) are shown below and the entire list is also available as a link in the [Downloads](@downloads) section.

```{r funct.clusterprofiler_gsea_go, results="asis"}
egoBP <- gseGO(geneList     = foldchanges,
              OrgDb        = org.Mm.eg.db,
              ont          = "BP",
              nPerm        = 1000,
              minGSSize    = minGSS,
              maxGSSize    = maxGSS,
              pvalueCutoff = pvalcutoff,
              verbose      = FALSE, 
              by='fgsea')
gseaGOBPresult <- egoBP@result
if (nrow(gseaGOBPresult)==0){
  gseaGOBPresult[1,] <- NA
}
gseaGOBPresult$category <- "BP"

egoMF <- gseGO(geneList     = foldchanges,
              OrgDb        = org.Mm.eg.db,
              ont          = "MF",
              nPerm        = 1000,
              minGSSize    = minGSS,
              maxGSSize    = maxGSS,
              pvalueCutoff = pvalcutoff,
              verbose      = FALSE, 
              by='fgsea')
gseaGOMFresult <- egoMF@result
if (nrow(gseaGOMFresult)==0){
  gseaGOMFresult[1,] <- NA
}
gseaGOMFresult$category <- "MF"

egoCC <- gseGO(geneList     = foldchanges,
              OrgDb        = org.Mm.eg.db,
              ont          = "CC",
              nPerm        = 1000,
              minGSSize    = minGSS,
              maxGSSize    = maxGSS,
              pvalueCutoff = pvalcutoff,
              verbose      = FALSE, 
              by='fgsea')
gseaGOCCresult <- egoCC@result
if (nrow(gseaGOCCresult)==0){
  gseaGOCCresult[1,] <- NA
}
gseaGOCCresult$category <- "CC"

gseaGOresults=do.call(rbind, list(gseaGOBPresult,gseaGOMFresult,gseaGOCCresult ))


## test to see if you actually return any results
test <- gseaGOresults
test$category <- NULL
if (all(is.na(test))){
  outputme <- FALSE
  cat("**There were no significant results**")
} else {
  outputme <- TRUE
  sanitize_datatable(do.call(rbind, list(gseaGOBPresult, gseaGOMFresult, gseaGOCCresult)))
}
```

```{r funct.clusterprofiler_gsea_go_output, results="hide", dependson=outputme}
tempoutfile <-file.path(tempdir(), paste("clusterprofiler_gsea_GO_results_for", contrast_id, "xlsx", sep="."))
rio::export(gseaGOresults, file=tempoutfile)
drop_upload(file=tempoutfile, dest=dropboxfiledir, overwrite=TRUE)
assign(paste("clusterprofiler_gsea_GO_results_for_", contrast_id, sep=""), drop_share(file.path(dropboxfiledir, paste("clusterprofiler_gsea_GO_results_for", contrast_id, "xlsx", sep=".")))$url)
```

##### KEGG Pathway GSEA with clusterProfiler
Analysis was performed to identify any KEGG pathways (with at least `r minGSS` genes in them) that were significantly dysregulated (genes in pathway could be up- or down-regulated simultaneously). The significantly dysregulated pathways (padj. < `r pvalcutoff`) are shown below and can be downloaded from a link in the [Downloads](@downloads) section.

```{r funct.clusterprofiler_gsea_kegg, results="asis"}
kk2 <- gseKEGG(geneList     = foldchanges,
               organism     = 'mmu',
               nPerm        = 1000,
               minGSSize    = minGSS,
               maxGSSize    = maxGSS,
               pvalueCutoff = pvalcutoff,
               verbose      = FALSE, 
               by='fgsea')
kkgsea_results <- kk2@result


if (nrow(kkgsea_results)==0){
    cat("**There were no significant results**")
    outputme <- FALSE
} else {
sanitize_datatable(kkgsea_results)
    outputme <- TRUE
}
```

```{r funct.clusterprofiler_gsea_kegg_output, results="hide", dependson=outputme}
tempoutfile <-file.path(tempdir(), paste("clusterprofiler_gsea_kegg_results_for", contrast_id, "xlsx", sep="."))
rio::export(kkgsea_results, file=tempoutfile)
drop_upload(file=tempoutfile, dest=dropboxfiledir, overwrite=TRUE)
assign(paste("clusterprofiler_gsea_kegg_results_for_", contrast_id, sep=""), drop_share(file.path(dropboxfiledir, paste("clusterprofiler_gsea_kegg_results_for", contrast_id, "xlsx", sep=".")))$url)
```



### Subset to Annotated Genes

Many of the differentially expressed "genes" are only predicted genes. Here we present the volcano plot, heatmap and GO enrichment results with only the annotated genes from that set.

```{r nopredicted}
annotated_sig_data <- import("annotatedstats_for.knockout_vs_wildtype.xlsx")
annotated_sig_genes <- annotated_sig_data %>% tbl_df() %>% filter(id!="id") %>% as.data.frame %>% .$id
```

#### Volcano plots with significant annotated genes

```{r annotavolcano}
stats = as.data.frame(res[annotated_sig_genes,c(2,6)])
volcano_density_plot(stats, title="")


stats = as.data.frame(res[annotated_sig_genes,c(2,6)]) %>%  row2colnames("ensemblid")
stats <- annotate_df2(df=stats, df_ensemblid_header = "ensemblid", biomart_ensembl_dataset= 'mmusculus_gene_ensembl',biomart_ensemblid_filter = "ensembl_gene_id", biomart_genesymbol_attribute = 'mgi_symbol', biomart_host="useast.ensembl.org" )
stats <- stats %>% tbl_df() %>% mutate(significant=ifelse(padj>pvalcutoff|is.na(padj), "NO", "YES"))
library(plotly)
p <- ggplot(stats, aes(x=log2FoldChange, y=-log10(padj),  text=mgi_symbol))+
  geom_point(alpha=0.6, size=2, color="blue")+
  theme_bw()
p <- ggplotly(p) 
p
```

#### Heatmap with significant annotated genes

```{r heatmapannotated, fig.height=18, fig.width=8}
sig_genes.sub <- annotated_sig_genes
# subset rlog transformed data to the significant genes of interest
sig_genes.sub.rlogmat <- rlogMat[sig_genes.sub,]
sig_genes.sub.rlogmat <- sig_genes.sub.rlogmat %>% row2colnames("ensemblid")

sig_genes.sub.rlogmat <- annotate_df2(df=sig_genes.sub.rlogmat, df_ensemblid_header = "ensemblid", biomart_ensembl_dataset= 'mmusculus_gene_ensembl',biomart_ensemblid_filter = "ensembl_gene_id", biomart_genesymbol_attribute = 'mgi_symbol', biomart_host="useast.ensembl.org" )


annots.sub <- summarydata[, c("genotype", "replicate", "researcher_sampleid")]
heatmap_data <- as.matrix(sig_genes.sub.rlogmat[, row.names(summarydata)])
class(heatmap_data) <- "numeric"
pheatmap(heatmap_data,
         annotation=annots.sub,
         clustering_distance_cols = "correlation",
         clustering_method = "ward.D2",
         main = "Differentially expressed genes",
         scale = "row",
         show_rownames = TRUE, 
         labels_row = sig_genes.sub.rlogmat$mgi_symbol, 
         fontsize_row = 8)
```

#### GO enrichment with only annotated genes

```{r GOannotated}
gene_list <- annotated_sig_data$mgi_symbol

#gprofileR
gprofiler_results <- gprofiler(query = gene_list, 
                               organism = "mmusculus", 
                               ordered_query = F, 
                               exclude_iea = F,
                               max_set_size = 0, 
                               correction_method = "fdr", 
                               hier_filtering = "none", 
                               domain_size = "annotated", 
                               custom_bg = "")

allterms <- gprofiler_results$term.id
GOs <- allterms[grep("GO:", allterms)]
pvals <- gprofiler_results$p.value[grep("GO:", allterms)]

gprofiler_results.simplified <- gprofiler_results[, c("term.id", "term.name", "domain", "p.value", "term.size", "query.size", "overlap.size", "intersection")]
names(gprofiler_results.simplified) <- c("term.id", "term.name",  "domain", "p.value","term.size", "query.size", "overlap.size", "assoc.gene.ids")


# Revigo BP
## Parameters to change
cutoff <- "0.7" #Allowed values: "0.90" "0.70" "0.50" "0.40" 
organism <- "Mus musculus" #Allowed values: See organism.list below
isPValue <- "yes" #Allowed values: "yes"  "no"
whatIsBetter <- "higher" #Allowed values: "higher" "lower" "absolute" "abs_log"
measure <- "SIMREL" #Allowed values: "RESNIK" "LIN" "SIMREL" "JIANG"
domain <- "BP"


#Do not change below
organism.list <- list(
"whole UniProt"=0, 
	"Homo sapiens"=9606,
	"Mus musculus"=10090,
	"Rattus norvegicus"=10116,
	"Bos taurus"=9913,
	"Gallus gallus"=9031,
	"Danio rerio"=7955,
	"Takifugu rubripes"=31033,
	"Xenopus laevis"=8355,
	"Drosophila melanogaster"=7227,
	"Caenorhabditis elegans"=6239,
	"Arabidopsis thaliana"=3702,
	"Oryza sativa"=39947,
	"Zea mays"=4577,
	"Saccharomyces cerevisiae"=4932,
	"Schizosaccharomyces pombe"=4896,
	"Dictyostelium discoideum"=44689,
	"Plasmodium falciparum"=5833,
	"Chlamydomonas reinhardtii"=3055,
	"Escherichia coli"=83333,
	"Bacillus subtilis"=1423,
	"Pseudomonas aeruginosa"=287,
	"Mycobacterium tuberculosis"=1773,
	"Mycoplasma genitalium"=2097,
	"Synechocystis sp."=1148
	)
organism.db <- as.character(organism.list[organism])

cat("**Biological Processes Domain**")

domain="BP"
mycommand=paste('revigo.pl -goterms', paste(GOs,collapse=","), '-gopvals', paste(pvals,collapse=","), '-cutoff', cutoff,  '-organism', organism.db, '-ispvalue', isPValue, '-whatisbetter', whatIsBetter, '-measure', measure, '-domain', domain,sep=" ")
mytempfile <- tempfile()
system2(command='perl', args=mycommand, stdout=mytempfile)
source(mytempfile)

cat("**Molecular Functions Domain**")

domain="MF"
mycommand=paste('revigo.pl -goterms', paste(GOs,collapse=","), '-gopvals', paste(pvals,collapse=","), '-cutoff', cutoff,  '-organism', organism.db, '-ispvalue', isPValue, '-whatisbetter', whatIsBetter, '-measure', measure, '-domain', domain,sep=" ")
mytempfile <- tempfile()
system2(command='perl', args=mycommand, stdout=mytempfile)
source(mytempfile)

cat("**Cellular Component Domain**")

domain="CC"
mycommand=paste('revigo.pl -goterms', paste(GOs,collapse=","), '-gopvals', paste(pvals,collapse=","), '-cutoff', cutoff,  '-organism', organism.db, '-ispvalue', isPValue, '-whatisbetter', whatIsBetter, '-measure', measure, '-domain', domain,sep=" ")
mytempfile <- tempfile()
system2(command='perl', args=mycommand, stdout=mytempfile)
source(mytempfile)

```

```{r funct.gprofiler_output_annotated, results="hide"}
tempoutfile <-file.path(tempdir(), paste("gprofiler_results_using_only_annotated_genes_for", contrast_id, "xlsx", sep="."))
rio::export(gprofiler_results.simplified, file=tempoutfile)
drop_upload(file=tempoutfile, dest=dropboxfiledir, overwrite=TRUE)
assign(paste("gprofiler_results_using_only_annotated_genes_for_", contrast_id, sep=""), drop_share(file.path(dropboxfiledir, paste("gprofiler_results_using_only_annotated_genes_for", contrast_id, "xlsx", sep=".")))$url)
```


# Knockout gene expression at the gene and  transcript level

We can use the DESeq2 normalized counts to look at the expression of the knockout gene.

```{r knockouttranscriptanalysis}
# import data at the transcript level
txi_salmon_transcript = tximport(sf_files, 
                      type="salmon", 
                      tx2gene=tx2gene,
                      importer=readr::read_tsv, 
                      countsFromAbundance="lengthScaledTPM",
                      txOut=TRUE)
counts_transcripts = round(data.frame(txi_salmon_transcript$counts, check.names=FALSE))
counts_transcripts = counts_transcripts[, order(colnames(counts_transcripts)), drop=FALSE]


# remove empty transcript rows and put into DESeq2 object
counts_transcripts <- counts_transcripts[rowSums(counts_transcripts>0)>1,]
txi_salmon_transcipt = subset_tximport(txi_salmon_transcript, rownames(counts_transcripts), colnames(counts_transcripts))
dds_transcript = DESeqDataSetFromTximport(txi_salmon_transcript, colData=summarydata, design=design)

# use size factors from gene level analysis
sizeFactors(dds_transcript) <- sizeFactors(dds)

dds_transcript = DESeq(dds_transcript, betaPrior=FALSE)
```

## Gene level

```{r knockoutexpressiongene}
geneid <- "ENSMUSG00000036225"
summarydata_dt <- tbl_df(summarydata)

normcounts_gene <-  as.data.frame(counts(dds, normalized=TRUE))[geneid,] %>% t %>% as.data.frame()
names(normcounts_gene) <- "value"
normcounts_gene <- row2colnames(normcounts_gene, "sampleid") %>% tbl_df()

# merge with metagdata to get genotypes
normcounts_gene_annot <- inner_join(normcounts_gene, summarydata_dt, by = c("sampleid" = "name"))
# plot
ggplot(normcounts_gene_annot, aes(x=sampleid,y=value, fill=genotype ))+geom_bar(stat="identity")+theme_bw()
ggplot(normcounts_gene_annot, aes(x=genotype, y=value, color=genotype))+geom_boxplot()+geom_point(data=normcounts_gene_annot, aes(y=value, x=genotype, fill=genotype), size=3) +theme_bw()
```

## Transcript level

All of the analyses so far have been at the gene level, but we can also look at expression at the transcript level. This may help use figure out what is going on with the knockout gene.


```{r knockoutexpressiontranscript}
ensembl = useMart("ENSEMBL_MART_ENSEMBL", dataset = "mmusculus_gene_ensembl", host = "useast.ensembl.org")
transcript_ids <- getBM(values="ENSMUSG00000036225", 
      attributes = "ensembl_transcript_id", 
      filters = "ensembl_gene_id",
      mart=ensembl)
summarydata_dt <- tbl_df(summarydata)

normcounts_transcript <-  as.data.frame(counts(dds_transcript, normalized=TRUE))[as.character(unlist(transcript_ids)),] %>% t %>% as.data.frame() %>% row2colnames(., "sampleid") %>% melt()
names(normcounts_transcript) <- c("sampleid", "transcriptid", "value")

# merge with metagdata to get genotypes
normcounts_transcript_annot <- inner_join(normcounts_transcript, summarydata_dt, by = c("sampleid" = "name"))
# plot
ggplot(normcounts_transcript_annot, aes(x=sampleid,y=value, fill=genotype ))+geom_bar(stat="identity")+theme_bw()+facet_grid(~transcriptid)
ggplot(normcounts_transcript_annot, aes(x=genotype, y=value, color=genotype))+geom_boxplot()+geom_point(data=normcounts_transcript_annot, aes(y=value, x=genotype, fill=genotype), size=3) +theme_bw()+facet_grid(~transcriptid)
```

We are seeing a reduction (though not total) of  Kctd1 expression in the knockout samples, but only for one transcript (ENSMUST00000025992). Lack of total loss is probably due to the cell specificity of the knockout.

---

# Downloads {#downloads}


## Gene counts

[Raw counts](`r rawcounts_shared_file`) - use this to repeat this analysis

[TPM matrix](`r tpm_shared_file`) - use this for looking at the expression of individual genes (i.e. plots of expression levels of individual genes)

[rlog stabilized data](`r rlog_shared_file`) - use this for analyses that rely on variance (ie. PCA, heatmaps)

## Differential Expression Statistics

[DESeq2 differential expression statistics](`r stats_knockout_vs_wildtype`)


## Overrepresentation GO enrichment

__**Domains:**__  
BP - Gene Ontology Biological Process  
MF - Gene Ontology Molecular Function   
CC - Gene Ontology Cellular Component  
tf - transcription factor motif enrichment  
cor - [CORUM][] protein complexes   
hp - [`Human Phenotype Ontology`][]  
mi - miRBase microRNA targets

[Gprofiler overrepresentation results](`r gprofiler_results_for_knockout_vs_wildtype`)


## Overrepresentation GO enrichment using only annotated genes

[Gprofiler overrepresentation results using only annotated genes](`r gprofiler_results_using_only_annotated_genes_for_knockout_vs_wildtype`)


---


---


# SessionInfo

```{r sessioninfo}
sessionInfo()
```


# References