---
title: "Quality Control"
author: "`r getOption('author')`"
date: "`r Sys.Date()`"
bibliography: bibliography.bib
params:
    bcbFile: "data/bcb.rda"
    outputDir: "."
---

```{r setup, message=FALSE}
library(bcbioRNASeq)

# Shared R Markdown settings
prepareRNASeqTemplate()
if (file.exists("setup.R")) {
    source("setup.R")
}

# Load bcbioRNASeq object
bcbName <- load(params$bcbFile)
bcb <- get(bcbName, inherits = FALSE)
interestingGroups(bcb) <- c("tissue", "treatment")

# Directory paths
outputDir <- params$outputDir
dataDir <- file.path(outputDir, "data")
countsDir <- file.path(outputDir, "results", "counts")
```

```{r header, child="_header.Rmd", eval=file.exists("_header.Rmd")}
```



```{r sample_metadata}
sampleMetadata(bcb)
```

[bcbio][] run data was imported from **`r metadata(bcb)[["uploadDir"]]`**.

```{r counts}
rawCounts <- counts(bcb, normalized = FALSE)
normalizedCounts <- counts(bcb, normalized = TRUE)
tpm <- tpm(bcb)
saveData(rawCounts, normalizedCounts, tpm, dir = dataDir)
writeCounts(rawCounts, normalizedCounts, tpm, dir = countsDir)

counts <- counts(bcb, normalized = FALSE)
rowData <- rowData(bcb)
annotated <- cbind(as.data.frame(counts), as.data.frame(rowData))
```



# Read metrics {.tabset}

## Total reads

```{r plot_total_reads}
plotTotalReads(bcb)
```

Some of these samples really do not have many reads...particularly OCP-CTL1,3 and 4 and OCP_ZA_1.

## Mapped reads

The number of mapped reads should correspond to the number of total reads.

```{r plot_mapped_reads}
plotMappedReads(bcb)
```


## Mapping rate

The genomic mapping rate represents the percentage of reads mapping to the reference genome. Low mapping rates are indicative of sample contamination, poor sequencing quality or other artifacts.

```{r plot_mapping_rate}
plotMappingRate(bcb)
```

We should drop OCP_BOTH_2 for poor mapping rate.


## Number of genes detected

```{r plot_genes_detected}
plotGenesDetected(bcb)
```

I'm honestly a bit surprised the gene detection levels aren't lower in the samples with low read numbers.

## Gene detection saturation

We should observe a linear trend in the number of genes detected with the number of mapped reads, which indicates that the sample input was not overloaded.

```{r plot_gene_saturation}
plotGeneSaturation(bcb)
```

The 3 OCP_CTL samples on the left are probably the ones with really low read numbers.

## Exonic mapping rate

Ideally, at least 60% of total reads should map to exons.

```{r plot_exonic_mapping_rate}
plotExonicMappingRate(bcb)
```

Looking good here.

## Intronic mapping rate

The majority of reads should map to exons and not introns.

```{r plot_intronic_mapping_rate}
plotIntronicMappingRate(bcb)
```

Also good here.

## rRNA mapping rate

Samples should have a ribosomal RNA (rRNA) contamination rate below 10%.

```{r plot_rrna_mapping_rate}
plotRRNAMappingRate(bcb)
```

Here it's the OCP_BOTH samples that have issues. We'll see how it looks on the PCA before deciding if it's a real problem though.

## 5'->3' bias

```{r plot_53_bias}
plot53Bias(bcb)
```

No sign of degradation here!

## Counts per gene

Generally, we expect similar count spreads for all genes between samples unless the library sizes or total RNA expression are different. The log10 TMM-normalized counts per gene normalization method [@Robinson:2010dd] equates the overall expression levels of genes between samples under the assumption that the majority of them are not differentially expressed. Therefore, by normalizing for total RNA expression by sample, we expect the spread of the log10 TMM-normalized counts per gene to be similar for every sample.

```{r plot_counts_per_gene}
plotCountsPerGene(bcb)
```

the narrow ranges on  OCP_CTL

## Count density

Generally, we expect similar count spreads for all genes between samples unless the total expressed RNA per sample is different.

```{r plot_count_density}
plotCountDensity(bcb)
```



# Fit modeling

Several quality metrics are first assessed to explore the fit of the model, before differential expression analysis is performed.


## Variance stabilization

The plots below show the standard deviation of normalized counts (`normalized_counts`) using `log2()`, `rlog()`, and variance stabilizing (`vst()`) transformations by `rank(mean)`. The transformations greatly reduce the standard deviation, with `rlog()` stabilizing the variance best across the mean.

```{r plot_mean_sd, fig.height=18, fig.width=6}
plotMeanSD(bcb)
```


## Dispersion

The following plot shows the dispersion by mean of normalized counts. We expect the dispersion to decrease as the mean of normalized counts increases.

```{r plot_disp_ests, fig.height=8, fig.width=8}
plotDispEsts(bcb)
```



# Sample similarity analysis

Before performing similarity analysis, we transform counts to log2, which acts to minimize large differences in sequencing depth and helps normalize all samples to a similar dynamic range. For RNA-seq count data, variance increases with the mean. Logarithmic transformation of normalized count values with a small pseudocount will account for large variations seen between the highest expressing genes so that these genes won't dominate the PCA plots. However, due to the strong noise among low count values due to Poisson, the general log2 transformation will amplify this noise, and instead, low count genes will now dominate the PCA plots. So instead, we use a transformation (`rlog()`) that gives similar results for high counts as a log2 transformation but also shrinks the values of low counts towards the genesâ€™ average across samples. We do this with the `rlog()` function in the [DESeq2][] package [@DESeq2], which we will later use for differential gene expression analysis.


## Principal component analysis (PCA)

PCA [@Jolliffe:2002wx] is a multivariate technique that allows us to summarize the systematic patterns of variations in the data. PCA takes the expression levels for genes and transforms it in principal component space, reducing each sample into one point. Thereby, we can separate samples by expression variation, and identify potential sample outliers. The PCA plot is a way to look at how samples are clustering.

```{r plot_pca, fig.height=12, fig.width=10}
plotPCA(bcb)
```


## Covariates correlation with PCs

When multiple factors may influence the results of a given experiment, it is useful to assess which of them is responsible for the most variance as determined by PCA. We adapted the method described by Daily et al. where they integrated a method to correlate covariates with principal components values to determine the importance of each factor.

Here we are showing the correlational analysis of the rlog transformed count data's principal components with the metadata covariates of interest. Significant correlations (FDR < 0.1) are shaded from blue (anti-correlated) to orange (correlated), with non-significant correlations shaded in gray.

```{r plot_pca_covariates}
plotPCACovariates(bcb)
```


## Hierarchical clustering

Inter-correlation analysis (ICA) is another way to look at how well samples cluster by plotting the correlation between the expression profiles of the samples.

```{r plot_correlation_heatmap, fig.height=8, fig.width=10}
plotCorrelationHeatmap(bcb)
```

## Drop BM samples


```{r dropbm}
bcb_sub <- bcb[,which(!colData(bcb)$tissue=="BM")]
```

```{r plot_pca_sub1, fig.height=12, fig.width=10}
plotPCA(bcb_sub, label=TRUE)
```

## Drop failed samples

Drop OCP_BOTH_2 for poor mapping rate.

```{r dropfailed}
bcb_sub <- bcb_sub[,which(!colData(bcb_sub)$sampleID=="OCP_BOTH_2")]
```

```{r plot_pca_sub2, fig.height=12, fig.width=10}
plotPCA(bcb_sub, label=TRUE)
```

Subset to only protein coding genes.

```{r dropnonprotein}
bcb_sub <- bcb_sub[which(annotated[,"biotype"]=="protein_coding"),]

plotPCA(bcb_sub, label=TRUE)
plotPCA(bcb_sub, label=FALSE)
```


```{r }
# this is a bunch of stuff so I can color the PCAs by numerical values, not just factors
dds <- bcbio(bcb_sub, "DESeqDataSet")
design(dds) <- ~1
dds <- DESeq(dds)
rld <- rlog(dds)

pca_loadings = function(object, ntop=500) {
  rv <- matrixStats::rowVars(assay(object))
  select <- order(rv, decreasing = TRUE)[seq_len(min(ntop, length(rv)))]
  pca <- prcomp(t(assay(object)[select, ]))
  percentVar <- pca$sdev^2/sum(pca$sdev^2)
  names(percentVar) = colnames(pca$x)
  pca$percentVar = percentVar
  return(pca)}
pc = pca_loadings(rld)
comps = data.frame(pc$x)
comps$name = rownames(comps)

# putting together covariages for plotting colors and shapes
mycoldata <- colData(bcb)
summarydata <- inner_join(as.data.frame(colData(bcb)), metadata(bcb)$metrics)

comps = comps %>% left_join(summarydata, by=c("name"="name"))

pca_plot = function(comps, nc1, nc2, colorby, shapeby) {
   c1str = paste0("PC", nc1)
   c2str = paste0("PC", nc2)
  if(!(c1str %in% colnames(comps) && c2str %in% colnames(comps))) {
    warning("Higher order components not found, skipping plotting.")
    return(NA)
  }
  ggplot(comps, aes_string(c1str, c2str, color=colorby, fill=colorby,shape=shapeby)) +
    geom_point(size=5) + theme_bw() +
    xlab(paste0(c1str, ": ", round(pc$percentVar[nc1] * 100), "% variance")) +
    ylab(paste0(c2str, ": ", round(pc$percentVar[nc2] * 100), "% variance"))+
scale_shape_manual(values=c(21,22,23,24,25))
                   }
pca_plot(comps, 1, 2, colorby="treatment", shapeby="treatment")
pca_plot(comps, 1, 2, colorby="xGC", shapeby="treatment")
pca_plot(comps, 1, 2, colorby="x5x3Bias", shapeby="treatment")
pca_plot(comps, 1, 2, colorby="totalReads", shapeby="treatment")
pca_plot(comps, 1, 2, colorby="rrnaRate", shapeby="treatment")
pca_plot(comps, 1, 2, colorby="library", shapeby="treatment")

```

Nothing is really consistently jumping out that would explain why the two ZA samples are clustering separately. Library size has some effect on the clustering, but isn't a factor with the two ZA samples in question. 


```{r plot_correlation_heatmap_sub1, fig.height=8, fig.width=10}
plotCorrelationHeatmap(bcb_sub)
```

Here, the samples OCP_ZA_3 and OCP_ZA_5 cluster with the GCSF and BOTH samples while the OCP_BOTH_3 and OCP_GCSF_2 cluster with the ZA and CTL samples. OCP_GSF_1 is out on it's own.

**Has there been a sample/data mixup somewhere along the way?**

# Looking at the previous OCP dataset

```{r olddata}
bcb_old <- loadRNASeq("~/Orchestra/PIs/sandra_mcallister/logfc_heatmaps/bcbio_combined/final")
saveData(bcb_old, dir="data")

rld <- as.data.frame(counts(bcb_sub, normalized="rlog"))
rld$ensgene <- rownames(rld)
meta <- as.data.frame(colData(bcb_sub))
rld_old <- as.data.frame(counts(bcb_old, normalized="rlog"))
rld_old$ensgene <- rownames(rld_old)
rld_new <- inner_join(rld, rld_old) 
rld_new$ensgene <- NULL
rld_new <- as.matrix(rld_new)

meta_old <- as.data.frame(colData(bcb_old))
meta_old$repeated <- "original"
meta_old <- meta_old %>% dplyr::select(-cellPopulation)
meta_old <-meta_old %>%  dplyr::select(sampleID ,sampleName, description,   libraryid, barcode ,repeated ,replicate, treatment)

names(meta) <- sub("barcodeIndex", "barcode", names(meta)) %>% sub("libraryID", "libraryid", .)
meta <- meta %>% dplyr::select(-barcodeAdapter, -jessID, -library, -tissue)
meta <-meta %>%  dplyr::select(sampleID ,sampleName, description,   libraryid, barcode ,repeated ,replicate, treatment)

meta_new <- rbind(meta, meta_old)
# all(meta_new$sampleID == names(rld_new))
meta_new$name <- meta_new$sampleID

pca_loadings_df = function(object, ntop=500) {
  rv <- matrixStats::rowVars(object)
  select <- order(rv, decreasing = TRUE)[seq_len(min(ntop, length(rv)))]
  pca <- prcomp(t(object[select, ]))
  percentVar <- pca$sdev^2/sum(pca$sdev^2)
  names(percentVar) = colnames(pca$x)
  pca$percentVar = percentVar
  return(pca)}


pc = pca_loadings_df(rld_new)
comps = data.frame(pc$x)
comps$name = rownames(comps)
comps = comps %>% left_join(meta_new, by=c("name"="name"))

pca_plot(comps, 1, 2, colorby="repeated", shapeby="treatment")


plotPCA(bcb_old, interestingGroups="treatment")
plotPCA(bcb_sub, interestingGroups="treatment")
```


```{r footer, child="_footer.Rmd", eval=file.exists("_footer.Rmd")}
```
