---
output:
  html_document:
    code_folding: hide
    theme: yeti
    toc: yes
    toc_float: true
    toc_depth: 6
    number_sections: true
    fig_height: 6 
title: "Church - Cell Anucleation RNAseq Analysis"
bibliography: references.bib
author: "John N Hutchinson"
---

[R]: https://www.r-project.org
[RStudio]: https://www.rstudio.com
[bcbio-rnaseq]: https://github.com/roryk/bcbio.rnaseq
[bcbio]: https://github.com/chapmanb/bcbio-nextgen
[DESeq2]: https://bioconductor.org/packages/release/bioc/html/DESeq2.html
[salmon]: https://combine-lab.github.io/salmon/
[tximport]: https://bioconductor.org/packages/release/bioc/html/tximport.html
[Bioconductor]: https://bioconductor.org
[Ensembl]: http://useast.ensembl.org/Mus_musculus/Info/Index


```{r setup1, echo=FALSE}
# Setup report details
clientname="Stan Wang"
clientemail="Stan_Wang@hms.harvard.edu"
lablocation="HMS" 
analystname="John Hutchinson"
analystemail="jhutchin@hsph.harvard.edu"
```

> RNA-Seq analysis for `r clientname` (`r clientemail`) at `r lablocation`. Contact `r analystname` (`r analystemail`) for additional details. 
> This document was generated on `r date()` using [R][] and [RStudio][]
 
```{r setup2, echo=FALSE}
knitr::opts_chunk$set(tidy=TRUE, highlight=TRUE, dev="png",
               cache=TRUE, highlight=TRUE, autodep=TRUE, warning=FALSE, error=FALSE,
               message=FALSE, prompt=TRUE, comment='', fig.cap='')
```

# Overview

Fastq files were processed in [bcbio][] and pseudo-count data generated by [salmon][]. Various RNAseq metrics were summarized with [bcbio-rnaseq][].

There are 3 biologic replicates of HEK293 cells for each different treatment:
  
  - **DMSO** - untreated samples, 
  
  - **enucleate** - treatedÂ and sorted for lack of a nucleus
  
  - **nuclei** - treated samples sorted for nuclei alone
  
  - **nucleated** - treated samples sorted for cells still containing nuclei 
  
All samples received the lowest dilution of ERCC spike-in mix 1 as the input RNA for library prep was 20ng per sample.

Samples were sequenced over 4 lanes, as oppposed to the [intial QC aanlysis][https://www.dropbox.com/s/pn6yz4lbtrf0iik/20170421-qc_summary.zip?dl=0], here I combine them before proceeding with the QC.

Here I will continue to look at some some QC metrics and unsupervised clustering after merging lanes, dropping failed sample and removing ribosomal RNA.


```{r load-libraries, echo=FALSE}
check_install = function(packages) {
   not_installed = setdiff(packages, rownames(installed.packages()))
   if(length(not_installed) > 0) {
      write(paste("The libraries", not_installed, "are not installed, aborting.",
                   sep=" "), stderr())
      stop()
   }
}
packages = c("ggplot2", "reshape", "gplots", "edgeR", "CHBUtils", "pheatmap","DESeq2", "tximport", "DT", "DEGreport", "dplyr", "janitor", "rio", "rdrop2", "biomaRt")
check_install(packages)
installed = lapply(packages, library, character.only = TRUE)
```

```{r dataload, eval=file.exists("RDATA.counts_and_summary")}
load("RDATA.counts_and_summary")
```

```{r qc-setup, results='hide', eval=!file.exists("RDATA.counts_and_summary")}
if (file.exists("/Volumes/orch/PIs/george_church/church_anucleated_rnaseq/bcbio/final/2017-04-06_bcbio/")){
  baseDir <- "/Volumes/orch/PIs/george_church/church_anucleated_rnaseq/bcbio/final/2017-04-06_bcbio/"
} else if (file.exists("/n/data1/cores/bcbio/PIs/george_church/church_anucleated_rnaseq/")) {
  baseDir <- "/n/data1/cores/bcbio/PIs/george_church/church_anucleated_rnaseq/bcbio/final/2017-04-06_bcbio/"
} else {
  print("no base directory found")
}

project_summary = file.path(baseDir, "project-summary.csv")
counts_file = file.path(baseDir, "combined.counts")
tx2genes_file = file.path(baseDir, "tx2gene.csv")
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442","#0072B2", "#D55E00", "#CC79A7")
summarydata = read.table(project_summary, header=TRUE, sep=",")
summarydata = summarydata[,colSums(is.na(summarydata)) < nrow(summarydata)]
# handle newer bcbio-nextgen runs that use description as the key
if("description" %in% colnames(summarydata)) {
  rownames(summarydata) = summarydata$description
  summarydata$Name = rownames(summarydata)
  summarydata$description = NULL
} else {
  rownames(summarydata) = summarydata$Name
  # summarydata$Name = NULL
}
summarydata = summarydata[order(rownames(summarydata)),]
summarydata <- clean_names(summarydata)

if (file.exists(tx2genes_file)) {
  sf_files = list.files(file.path(dirname(tx2genes_file), "../../"), pattern="quant.sf", recursive=TRUE, full.names=TRUE)
  if(length(sf_files) > 0) {
    sf_files = sf_files[order(sf_files)]
    names(sf_files) = rownames(summarydata)
    tx2gene = read.table(tx2genes_file, sep=",", row.names=NULL, header=FALSE)
    txi.salmon = tximport(sf_files, type="salmon", tx2gene=tx2gene,
             importer=readr::read_tsv, countsFromAbundance="lengthScaledTPM")
    counts = round(data.frame(txi.salmon$counts, check.names=FALSE))
} else {
  counts = read.table(counts_file, header=TRUE, row.names="id", check.names=FALSE)
}}
counts = counts[, order(colnames(counts)), drop=FALSE]

# this is a list of all non user-supplied metadata columns that could appear
known_columns = c("rrna_rate", "duplication_rate_of_mapped", "mapped_reads", "mapped_paired_reads", "quality_format", "intergenic_rate", "sequence_length", "exonic_rate", "total_reads", "percentgc", "rrna", "duplicates", "name", "sequences_flagged_as_poor_quality", "average_insert_size", "intronic_rate", "x5_3_bias", "fragment_length_mean","x_gc", "mapped_reads_pct")
summarydata[,"mapped_reads_pct"] <- (summarydata$mapped_reads/summarydata$total_reads)*100

metadata = summarydata[, !colnames(summarydata) %in% known_columns, drop=FALSE]
metadata = metadata[, colSums(is.na(metadata)) < nrow(metadata), drop=FALSE]
metadata <- metadata[, c( "treatment", "lane", "replicate")] 
```

# Data manipulations

## Merge lanes

```{r mergelanes}
sampleids <- unique(summarydata$sampleid)
counts.summed <- matrix(nrow=nrow(counts), ncol=length(sampleids))

for (n in 1:length(sampleids)){
  sampleid <- sampleids[n]
  indices <- grep(sampleid, names(counts))
  counts.summed[,n] <-  rowSums(counts[,indices])
}

counts.summed <- as.data.frame(counts.summed)
names(counts.summed) <- sampleids
row.names(counts.summed) <- row.names(counts)

metadata <- summarydata %>% tbl_df() %>% dplyr::select(sampleid, treatment, replicate) %>% distinct(sampleid, treatment, replicate) %>% as.data.frame() %>% col2rownames(.,"sampleid", removecol = FALSE )

rm(summarydata)
counts <- counts.summed
#identical(row.names(metadata), names(counts))
```

## Drop failed samples

Sample nucleated_3 appears to have failed, as shown in the previous report [here][https://www.dropbox.com/s/pn6yz4lbtrf0iik/20170421-qc_summary.zip?dl=0], so will be dropped.

```{r dropfailures}
metadata <- metadata[!grepl("nucleated_3", row.names(metadata)),]
counts <- counts[,!grepl("nucleated_3", names(counts))]
```


```{r sanitize-datatable}
sanitize_datatable = function(df, ...) {
 # remove dashes which cause wrapping
 DT::datatable(df, ..., rownames=gsub("-", "_", rownames(df)),
                   colnames=gsub("-", "_", colnames(df)))
}
```

```{r set-random-seed}
# set seed for reproducibility
set.seed(1454944673)
```

## Updated sample metadata

```{r summary-table, echo=FALSE, cache=FALSE}
sanitize_datatable(metadata, style='bootstrap')
```

```{r heatmap-function}
get_heatmap_fn = function(summarydata) {
    # return the pheatmap function with or without metadata
    if(ncol(metadata) == 0) {
       return(pheatmap)
    }
    else {
    # rownames(metadata) = summarydata$Name
    heatmap_fn = function(data, ...) {
        pheatmap(data, annotation=metadata, clustering_method = "ward.D2",
        clustering_distance_cols = "correlation", ...)
    }
    return(heatmap_fn)
}}
heatmap_fn = get_heatmap_fn(summarydata)
```

## Remove ribosomal and mitochondrial genes

```{r rRNA removal}
ensemblmart = useMart(biomart = "ENSEMBL_MART_ENSEMBL", dataset = "hsapiens_gene_ensembl", host = "useast.ensembl.org")

conversions = getBM(attributes = c("ensembl_gene_id", "hgnc_symbol", "gene_biotype", "chromosome_name"), mart =ensemblmart)

# id rRNA genes by biotype coding
rrna_biotypes = c("rRNA", "Mt_rRNA", "misc_RNA", "snRNA", "snoRNA", "tRNA", "Mt_tRNA")
rrna_genes <- unique(subset(conversions, gene_biotype %in% rrna_biotypes)$ensembl_gene_id)

#id mitochondrial proteing coding genes by chromosome
mt_genes <- unique(subset(conversions, conversions$chromosome_name=="MT" & conversions$gene_biotype=="protein_coding")$ensembl_gene_id)

# Analysis without mt and rRNA genes
counts <- counts[!rownames(counts) %in% rrna_genes & !rownames(counts) %in% mt_genes, ]
```

# Quality assessments

## Boxplot of log10 counts per gene

Generally, we expect similar count spreads for all genes between samples unless the library sizes or total RNA expression are different.

```{r boxplot-raw}
melted = melt(counts)
colnames(melted) = c("sample", "count")
melted$sample = factor(melted$sample)
melted = melted[order(melted$sample),]
melted$count = log(melted$count)
ggplot(melted, aes(x=sample, y=count)) + geom_boxplot() +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) + xlab("")
```

## Boxplot of log10 TMM-normalized counts per gene

Trimmed mean of M-values (TMM) normalization is described 
[here](http://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-3-r25) [@Robinson2010]

Robinson, M. D., & Oshlack, A. (2010). A scaling normalization method for differential expression analysis of RNA-seq data. Genome Biology, 11(3). doi:10.1186/gb-2010-11-3-r25

Generally, we expect similar count spreads for all genes between samples unless the total expressed RNA per sample is different. With the exception of nucleated_3 and nuclei_3, the samples look good, with similar log<sub>10</sub> DESeq2-normalized counts per gene densities:

```{r boxplot-normalized}
y = DGEList(counts=counts)
y = calcNormFactors(y)
normalized_counts = cpm(y, normalized.lib.sizes=TRUE)
melted = melt(normalized_counts)
colnames(melted) = c("gene", "sample", "count")
melted$sample = factor(melted$sample)
melted = melted[order(melted$sample),]
melted$count = log(melted$count)
ggplot(melted, aes(x=sample, y=count)) + geom_boxplot() +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) + xlab("")
```

## Density of normalized counts

nuclei_3 is still looking like an outlier here, but maybe normalization with the ERCC controls will help

```{r density-normalized}
melted.annot <- merge(melted, metadata, by.x="sample", by.y="sampleid")
ggplot(melted.annot, aes(x=count, group=sample, color=sample)) +
    geom_density() +
    theme_bw(base_size=10) +
    theme(panel.grid.major = element_line(size = .5, color = "grey"),
          axis.text.x = element_text(angle=90)) + xlab("")
```

# Sample Similarity Analyses (Unsupervised clustering)

## Correlation heatmap of TMM-normalized counts {.tabset}

### Correlation (Spearman)

Correlations are still not ideal

```{r spearman-heatmap-normalized, eval=ncol(counts) > 1}
metadata$replicate <- as.character(metadata$replicate)
metadata$sampleid <-NULL 
heatmap_fn(cor(normalized_counts, method="spearman") )
```

## PCA plots {.tabset}

```{r pca, eval=ncol(counts) > 1}
metadata <- row2colnames(metadata, "sampleid")
dds = DESeqDataSetFromMatrix(countData=counts, colData=metadata, design=~treatment)
vst = varianceStabilizingTransformation(dds)
pca_loadings = function(object, ntop=500) {
  rv <- matrixStats::rowVars(assay(object))
  select <- order(rv, decreasing = TRUE)[seq_len(min(ntop,
      length(rv)))]
  pca <- prcomp(t(assay(object)[select, ]))
  percentVar <- pca$sdev^2/sum(pca$sdev^2)
  names(percentVar) = colnames(pca$x)
  pca$percentVar = percentVar
  return(pca)}
pc = pca_loadings(vst)
comps = data.frame(pc$x)
comps$name = rownames(comps)
library(dplyr)
comps = comps %>% left_join(metadata, by=c("name"="sampleid"))
colorby = "name"
```

```{r pca-plotter}
#pca-plotter
pca_plot = function(comps, nc1, nc2, colorby, shapeby) {
   c1str = paste0("PC", nc1)
   c2str = paste0("PC", nc2)
  if(!(c1str %in% colnames(comps) && c2str %in% colnames(comps))) {
    warning("Higher order components not found, skipping plotting.")
    return(NA)
  }
  ggplot(comps, aes_string(c1str, c2str, color=colorby, shape=shapeby)) +
    geom_point(size=5) + theme_bw() +
    xlab(paste0(c1str, ": ", round(pc$percentVar[nc1] * 100), "% variance")) +
    ylab(paste0(c2str, ": ", round(pc$percentVar[nc2] * 100), "% variance"))
  }
```

### PC1 vs. PC2

The samples are still not clustering like we would like.

```{r PC1-PC2}
comps$replicate <- as.character(comps$replicate)
pca_plot(comps, 1, 2, colorby="treatment", shapeby="replicate")
```

### PC3 vs. PC4
```{r PC3-PC4}
pca_plot(comps, 3, 4, colorby="treatment", shapeby="replicate")
```

### PC5 vs. PC6
```{r PC5-PC6}
pca_plot(comps, 5, 6, colorby="treatment", shapeby="replicate")
```

### Variance explained by component
```{r component-loadings}
ggplot(data.frame(component=reorder(names(pc$percentVar), -pc$percentVar),
                  percent_var=pc$percentVar),
       aes(component, percent_var)) + geom_bar(stat='identity') +
  ylab("percent of total variation") + xlab("") + theme_bw()
```

---

# SessionInfo

```{r sessioninfo}
sessionInfo()
```


# References