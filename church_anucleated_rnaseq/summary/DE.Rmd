---
output:
  html_document:
    code_folding: hide
    theme: yeti
    toc: yes
    toc_float: true
    toc_depth: 6
    number_sections: true
    fig_height: 6 
title: "Church - Cell Anucleation RNAseq Analysis"
bibliography: references.bib
author: "John N Hutchinson"
---

[R]: https://www.r-project.org
[RStudio]: https://www.rstudio.com
[bcbio-rnaseq]: https://github.com/roryk/bcbio.rnaseq
[bcbio]: https://github.com/chapmanb/bcbio-nextgen
[DESeq2]: https://bioconductor.org/packages/release/bioc/html/DESeq2.html
[salmon]: https://combine-lab.github.io/salmon/
[tximport]: https://bioconductor.org/packages/release/bioc/html/tximport.html
[Bioconductor]: https://bioconductor.org
[Ensembl]: http://useast.ensembl.org/Mus_musculus/Info/Index
[RUVseq]: https://bioconductor.org/packages/release/bioc/html/RUVSeq.html

```{r setup1, echo=FALSE}
# Setup report details
clientname="Stan Wang"
clientemail="Stan_Wang@hms.harvard.edu"
lablocation="HMS" 
analystname="John Hutchinson"
analystemail="jhutchin@hsph.harvard.edu"
```

> RNA-Seq analysis for `r clientname` (`r clientemail`) at `r lablocation`. Contact `r analystname` (`r analystemail`) for additional details. 
> This document was generated on `r date()` using [R][] and [RStudio][]
 
```{r setup2, echo=FALSE}
knitr::opts_chunk$set(tidy=TRUE, highlight=TRUE, dev="png",
               cache=TRUE, highlight=TRUE, autodep=TRUE, warning=FALSE, error=FALSE,
               message=FALSE, prompt=TRUE, comment='', fig.cap='')
```

# Overview

Fastq files were processed in [bcbio][] and pseudo-count data generated by [salmon][]. Various RNAseq metrics were summarized with [bcbio-rnaseq][].

There are 3 biologic replicates of HEK293 cells for each different treatment:
  
  - **DMSO** - untreated samples, 
  
  - **enucleate** - treatedÂ and sorted for lack of a nucleus
  
  - **nuclei** - treated samples sorted for nuclei alone
  
  - **nucleated** - treated samples sorted for cells still containing nuclei 
  
All samples received the lowest dilution of ERCC spike-in mix 1 as the input RNA for library prep was 20ng per sample.

Samples were sequenced over 4 lanes, I combined them at the raw data level before proceeding with the differential expression.  I also drop a  failed sample and remove ribosomal and mitochondrial RNA.

Here I will look at the effects of ERCC spikein based normalization (using [RUVseq][] [@Risso2014] and run differential expression analyses targeting the differences between samples with and without succesful anucleation.

Differential gene expression (DGE) analysis of count data from [salmon][] [@Patro2015] was performed with the [Bioconductor][] [R][] package [DESeq2][] [@Love2014]. Counts were fit to a negative binomial model, and dispersion estimates were generated using the mean values from the maximum likelihood estimate of log2 fold changes, optimizing the Cox-Reid adjusted profile likelihood.

# Setup
- load R libraries and functions, data and metadata
 
## Libraries

- R and Bioconductor packages necessary for the analysis

```{r load-libraries, echo=FALSE}
check_install = function(packages) {
   not_installed = setdiff(packages, rownames(installed.packages()))
   if(length(not_installed) > 0) {
      write(paste("The libraries", not_installed, "are not installed, aborting.",
                   sep=" "), stderr())
      stop()
   }
}
packages = c("ggplot2", "reshape", "gplots", "edgeR", "CHBUtils", "pheatmap","DESeq2", "tximport", "DT", "DEGreport", "dplyr", "janitor", "rio", "rdrop2", "biomaRt", "knitr", "rdrop2")
check_install(packages)
installed = lapply(packages, library, character.only = TRUE)
```

## Data and metadata

- load in the data and metadata for the processed samples

```{r importdata, results='hide'}
dropboxfiledir <- "/HBC Team Folder (1)/Consults/george_church/church_anucleated_rnaseq/files"
pvalcutoff=0.1
lfccutoff=1
minGSS=1
maxGSS=1e6
usebetaprior=TRUE
uselfcshrink=FALSE
numgenesplotted=6

if (file.exists("/Users/jnhutchinson/Orchestra/PIs/george_church/church_anucleated_rnaseq/bcbio2_merged/final/2017-05-23_bcbio2_merged/")){
  baseDir <- "/Users/jnhutchinson/Orchestra/PIs/george_church/church_anucleated_rnaseq/bcbio2_merged/final/2017-05-23_bcbio2_merged/"
} else if (file.exists("/n/data1/cores/bcbio/PIs/george_church/church_anucleated_rnaseq/bcbio2_merged/final/2017-05-23_bcbio2_merged/")) {
  baseDir <- "/n/data1/cores/bcbio/PIs/george_church/church_anucleated_rnaseq/bcbio2_merged/final/2017-05-23_bcbio2_merged/"
} else {
  print("no base directory found")
}

project_summary = file.path(baseDir, "project-summary.csv")
counts_file = file.path(baseDir, "combined.counts")
tx2genes_file = file.path(baseDir, "tx2gene.csv")
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442","#0072B2", "#D55E00", "#CC79A7")
summarydata = read.table(project_summary, header=TRUE, sep=",")
summarydata = summarydata[,colSums(is.na(summarydata)) < nrow(summarydata)]
# handle newer bcbio-nextgen runs that use description as the key
if("description" %in% colnames(summarydata)) {
  rownames(summarydata) = summarydata$description
  summarydata$Name = rownames(summarydata)
  summarydata$description = NULL
} else {
  rownames(summarydata) = summarydata$Name
  # summarydata$Name = NULL
}
summarydata = summarydata[order(rownames(summarydata)),]
summarydata <- clean_names(summarydata)

# salmon import for regular genes
sf_files = list.files(file.path(dirname(tx2genes_file), "../"), pattern="quant.sf", recursive=TRUE, full.names=TRUE)
sf_files = sf_files[order(sf_files)]
names(sf_files) = rownames(summarydata)
tx2gene = read.table(tx2genes_file, sep=",", row.names=NULL, header=FALSE)
txi.salmon = tximport(sf_files, type="salmon", tx2gene=tx2gene,
                      importer=readr::read_tsv, countsFromAbundance="lengthScaledTPM")

# this is a list of all non user-supplied metadata columns that could appear
known_columns = c("rrna_rate", "duplication_rate_of_mapped", "mapped_reads", "mapped_paired_reads", "quality_format", "intergenic_rate", "sequence_length", "exonic_rate", "total_reads", "percentgc", "rrna", "duplicates", "name", "sequences_flagged_as_poor_quality", "average_insert_size", "intronic_rate", "x5_3_bias", "fragment_length_mean","x_gc", "mapped_reads_pct")
summarydata[,"mapped_reads_pct"] <- (summarydata$mapped_reads/summarydata$total_reads)*100

metadata = summarydata[, !colnames(summarydata) %in% known_columns, drop=FALSE]
metadata = metadata[, colSums(is.na(metadata)) < nrow(metadata), drop=FALSE]
metadata <- metadata[, c( "treatment", "replicate", "sampleid")] 
metadata <- row2colnames(metadata, "file_name")
metadata$description <- metadata$file_name
```

## Spikein data

- examine the correlations with expected values based on inter-relations of ERCC spikeins

```{r loadspikein}
library(readr)
library(tidyr)
ercc_file = file.path(baseDir, "ERCC_Controls_Analysis.txt")
spike_file = file.path(baseDir, "spikein.sf")
spikes = read_tsv(spike_file, progress=FALSE)
ercc = read_tsv(ercc_file, progress=FALSE,
                col_names=c("id", "ercc_id", "group", "mix1", "mix2", "fc", "log2fc"),
                skip=1)
correlations = ercc %>%
  left_join(spikes, by=c("ercc_id"="name")) %>%
  na.omit() %>%
  group_by(group, sample) %>%
  summarise(mix1cor=cor(log2(mix1), log2(tpm + 1)),
            mix2cor=cor(log2(mix2), log2(tpm + 1))) %>% 
  unite(col=id, sample, group, sep="-") %>% 
  as.data.frame() %>% 
  col2rownames("id") 
correlations[is.na(correlations)] <- 0  

#pheatmap(correlations[,1], cluster_rows = FALSE, cluster_cols = FALSE, cellwidth = 20, labels_row = row.names(correlations), gaps_row = c(12,24,36), main="Correlation plot of observed ERCC spikein levels with expected levels", scale="row")
  
combined = ercc %>%
  left_join(spikes, by=c("ercc_id"="name")) %>%
  na.omit()


library(broom)
mfits = combined %>% group_by(sample, group) %>%
  do(fit=lm(log2(tpm+1) ~ log2(mix1), data=.))

library(scales)
ggplot(combined, aes(numreads+1, mix1+1, color=group)) +
  geom_point() +
  stat_smooth(se=FALSE, method="lm") +
  facet_wrap(~sample) +
  scale_x_continuous(trans=log2_trans()) +
  scale_y_continuous(trans=log2_trans())+
  ggtitle("Groupwise relations between observed and expected ERCC spikein levels")
```

As with the QC results, the nucleated_3 sample looks really bad. We'll exclude it later.

```{r spikein_integration}
# get the names of the spikein directories
bcbio_metadata <- import(file.path(baseDir, "../../config/bcbio2_merged.csv" )) %>% 
  clean_names() %>% 
  tbl_df(  ) %>% 
  mutate(samplename=gsub(".fastq.gz", "", samplename))
# get the names of the spikein genes
spikein_sf <- read.table(file.path(baseDir, "../../spikein/spikein.sf"), sep="\t", header=TRUE)
tx2gene_spikein <- as.data.frame(cbind(as.character(unique(spikein_sf$name)),as.character(unique(spikein_sf$name))))

spikein_dirs = file.path(baseDir, "../../spikein", bcbio_metadata$description)
spikein_files=file.path(spikein_dirs,"quant", "quant.sf")
names(spikein_files) = as.character(bcbio_metadata$samplename)

txi.salmon.spikein = tximport(spikein_files, type="salmon", tx2gene=tx2gene_spikein,
                        importer=readr::read_tsv, countsFromAbundance="lengthScaledTPM")

colnames(txi.salmon.spikein$counts) <-     as.character(unlist(bcbio_metadata$description[match(colnames(txi.salmon.spikein$counts),    bcbio_metadata$samplename)]))
colnames(txi.salmon.spikein$abundance) <-  as.character(unlist(bcbio_metadata$description[match(colnames(txi.salmon.spikein$abundance), bcbio_metadata$samplename)]))
colnames(txi.salmon.spikein$length) <-     as.character(unlist(bcbio_metadata$description[match(colnames(txi.salmon.spikein$length),    bcbio_metadata$samplename)]))

txi.salmon.spikein$counts <- txi.salmon.spikein$counts[,order(colnames(txi.salmon.spikein$counts))]
txi.salmon.spikein$abundance <- txi.salmon.spikein$abundance[,order(colnames(txi.salmon.spikein$abundance))]
txi.salmon.spikein$length <- txi.salmon.spikein$length[,order(colnames(txi.salmon.spikein$length))]

# identical(as.character(colnames(txi.salmon$counts)), as.character(colnames(txi.salmon.spikein$counts)))
# identical(as.character(names(txi.salmon$abundance)), as.character(names(txi.salmon.spikein$abundance)))
# identical(as.character(names(txi.salmon$length)), as.character(names(txi.salmon.spikein$length)))


txi.salmon.all <- list(counts=rbind(txi.salmon$counts, txi.salmon.spikein$counts),
                       abundance=rbind(txi.salmon$abundance, txi.salmon.spikein$abundance),
                       length=rbind(txi.salmon$length, txi.salmon.spikein$length),
                       countsFromAbundance=txi.salmon$countsFromAbundance)

```

## Functions

- custom R functions to make the analysis easier

```{r functions, echo=FALSE}
#pca-plotter

pca_loadings = function(object, ntop=500) {
  rv <- matrixStats::rowVars(object)
  select <- order(rv, decreasing = TRUE)[seq_len(min(ntop,      length(rv)))]
  pca <- prcomp(t(object[select, ]))
  percentVar <- pca$sdev^2/sum(pca$sdev^2)
  names(percentVar) = colnames(pca$x)
  pca$percentVar = percentVar
  return(pca)
  }

#sanitize-datatable
sanitize_datatable = function(df, ...) {
 # remove dashes which cause wrapping
 DT::datatable(df, ..., rownames=gsub("-", "_", rownames(df)),
                   colnames=gsub("-", "_", colnames(df)))
}

#heatmap-function
get_heatmap_fn = function(summarydata) {
    # return the pheatmap function with or without metadata
    if(ncol(metadata) == 0) {
       return(pheatmap)
    }
    else {
    # rownames(metadata) = summarydata$Name
    heatmap_fn = function(data, ...) {
        pheatmap(data, annotation=metadata, clustering_method = "ward.D2",
        clustering_distance_cols = "correlation", ...)
    }
    return(heatmap_fn)
}}
heatmap_fn = get_heatmap_fn(summarydata)



annotate_df2 <- function (df, df_ensemblid_header, biomart_ensembl_dataset= 'hsapiens_gene_ensembl',biomart_ensemblid_filter = "ensembl_gene_id", biomart_genesymbol_attribute = 'hgnc_symbol', biomart_host="www.ensembl.org") {
  require(biomaRt)
  ensembl = useMart("ENSEMBL_MART_ENSEMBL", dataset = biomart_ensembl_dataset, host = biomart_host)
  annot.df = getBM(attributes = c(biomart_ensemblid_filter, biomart_genesymbol_attribute, "description"), filters = c(biomart_ensemblid_filter), values = as.character(df[, df_ensemblid_header]), mart = ensembl)
  m = merge(df, annot.df, by.x = df_ensemblid_header, by.y = biomart_ensemblid_filter,all.x = T)
  return(m)
}

subset_tximport = function(txi, rows, columns) {
  txi$counts = txi$counts[rows, columns]
  txi$abundance = txi$abundance[rows, columns]
  txi$length = txi$length[rows, columns]
  return(txi)
}

DESeqDataSetFromTximport <- function(txi, colData, design, ...) {
  counts <- round(txi$counts)
  mode(counts) <- "integer"
  dds <- DESeqDataSetFromMatrix(countData=counts, colData=colData, design=design, ...)
  stopifnot(txi$countsFromAbundance %in% c("no","scaledTPM","lengthScaledTPM"))
  if (txi$countsFromAbundance %in% c("scaledTPM","lengthScaledTPM")) {
    message("using length scaled TPM counts from tximport")
  } else {
    message("using counts and average transcript lengths from tximport")
    lengths <- txi$length
    dimnames(lengths) <- dimnames(dds)
    assays(dds)[["avgTxLength"]] <- lengths
  }
  return(dds)
}

pool_counts <- function(counts, pattern = "_L\\d+") {
    # Ensure that counts are input as matrix
    counts <- as.matrix(counts)
    # Obtain the unique pooled sample names
    if (!all(grepl(pattern, colnames(counts)))) {
        stop("Samples don't match lane grep pattern")
    }
    stem <- str_replace(colnames(counts), pattern, "") %>% unique %>% sort
    # Perform [rowSums()] on the matching columns per sample
    lapply(seq_along(stem), function(a) {
        counts %>%
            .[, grepl(paste0("^", stem[a], pattern), colnames(.))] %>%
            rowSums
    }) %>%
        set_names(stem) %>%
        do.call(cbind, .) %>%
        # [round()] here otherwise [DESeq()] will error out
        round
}

pool_dds2 <- function (dds, pattern = "_L\\d+", save = FALSE) {
    check_dds(dds)
    import_tidy_verbs()
    envir <- parent.frame()
    design <- design(dds)
    countData <- counts(dds, normalized = FALSE) %>% pool_counts
    colData <- colData(dds) %>% as.data.frame %>% mutate(file_name = str_replace(.data$file_name, 
        pattern, ""), description = str_replace(.data$description, 
        pattern, ""), lane = NULL, sizeFactor = NULL) %>% distinct %>% 
        set_rownames(.$description)
    if (!identical(colData$file_name, colnames(countData))) {
        stop("File name mismatch in colData and countData")
    }
    colnames(countData) <- colData$description
    if (!identical(rownames(colData), colnames(countData))) {
        stop("Description mismatch in colData and countData")
    }
    pooled_dds <- DESeqDataSetFromMatrix(countData = countData, 
        colData = colData, design = design) %>% DESeq
    if (isTRUE(save)) {
        write_pooled_counts <- function(counts, dir = "results/counts") {
            dir.create(dir, recursive = TRUE, showWarnings = FALSE)
            name <- deparse(substitute(counts))
            counts %>% as.data.frame %>% rownames_to_column("ensembl_gene_id") %>% 
                as_tibble %>% write_csv(path = file.path(dir, 
                paste0(paste("pooled", name, sep = "_"), ".csv.gz")))
        }
        normalized_counts <- counts(pooled_dds, normalized = TRUE)
        assign("pooled_normalized_counts", normalized_counts, 
            envir = envir)
        write_pooled_counts(normalized_counts)
        raw_counts <- counts(pooled_dds, normalized = FALSE)
        assign("pooled_raw_counts", raw_counts, envir = envir)
        write_pooled_counts(raw_counts)
    }
    pooled_dds
}

```

# Data manipulations

## Remove ribosomal and mitochondrial genes

- using Ensembl annotations, removed any genes annotated as ribosomal or mitochondrial RNA

```{r rRNA removal}
ensemblmart = useMart(biomart = "ENSEMBL_MART_ENSEMBL", dataset = "hsapiens_gene_ensembl", host = "useast.ensembl.org")

conversions = getBM(attributes = c("ensembl_gene_id", "hgnc_symbol", "gene_biotype", "chromosome_name"), mart =ensemblmart)

# id rRNA genes by biotype coding
rrna_biotypes = c("rRNA", "Mt_rRNA", "misc_RNA", "snRNA", "snoRNA", "tRNA", "Mt_tRNA")
rrna_genes <- unique(subset(conversions, gene_biotype %in% rrna_biotypes)$ensembl_gene_id)

#id mitochondrial proteing coding genes by chromosome
mt_genes <- unique(subset(conversions, conversions$chromosome_name=="MT" & conversions$gene_biotype=="protein_coding")$ensembl_gene_id)

# Analysis without mt and rRNA genes
txi.salmon.all$counts <-txi.salmon.all$counts[!rownames(txi.salmon.all$counts) %in% rrna_genes & !rownames(txi.salmon.all$counts) %in% mt_genes, ]
txi.salmon.all$abundance <-txi.salmon.all$abundance[!rownames(txi.salmon.all$abundance) %in% rrna_genes & !rownames(txi.salmon.all$abundance) %in% mt_genes, ]
txi.salmon.all$length <-txi.salmon.all$length[!rownames(txi.salmon.all$length) %in% rrna_genes & !rownames(txi.salmon.all$length) %in% mt_genes, ]
```

## Drop  samples

Sample nucleated_3 appears to have failed, as shown in the previous report [here][https://www.dropbox.com/s/pn6yz4lbtrf0iik/20170421-qc_summary.zip?dl=0] and the ERCC spikein results, so will be dropped.

```{r dropfailures}
dropsamples <-  c("nucleated_3")

index <-(colnames(txi.salmon.all$counts) %in%  dropsamples)
txi.salmon.all$counts <- txi.salmon.all$counts[,!index ]
txi.salmon.all$abundance <-txi.salmon.all$abundance[,!index ]
txi.salmon.all$length <-txi.salmon.all$length[,!index ]

index <-(colnames(txi.salmon$counts) %in%  dropsamples)
txi.salmon$counts <- txi.salmon$counts[,!index ]
txi.salmon$abundance <-txi.salmon$abundance[,!index ]
txi.salmon$length <-txi.salmon$length[,!index ]

metadata <-   metadata[!(rownames(metadata) %in% dropsamples),,drop=TRUE]
metadata$treatment <- droplevels(metadata$treatment)

summarydata <- summarydata[!(rownames(summarydata) %in% dropsamples),]
summarydata$treatment <- droplevels(summarydata$treatment)
```

```{r set-random-seed}
# set seed for reproducibility
set.seed(1454944673)
```

## Updated sample metadata

```{r summary-table, echo=FALSE, cache=FALSE}
sanitize_datatable(as.data.frame(metadata), style='bootstrap')
```


```{r write-tpm-matrix, results="hide"}
#rawcounts
counts = round(data.frame(txi.salmon.all$counts, check.names=FALSE))
tempoutfile <-file.path(tempdir(), "raw_counts.csv")
rio::export(counts, file=tempoutfile)
drop_upload(file=tempoutfile, dest=dropboxfiledir, overwrite=TRUE)
rawcounts_shared_file <-  drop_share(file.path(dropboxfiledir, "rawcounts.csv"))$url

#TPM
tpm = txi.salmon.all$abundance %>%
  as.data.frame() %>%
  tibble::rownames_to_column()
names(tpm)[1] <- "ensemblid"
tpm <- annotate_df2(df=tpm, df_ensemblid_header = "ensemblid", biomart_ensembl_dataset= 'mmusculus_gene_ensembl',biomart_ensemblid_filter = "ensembl_gene_id", biomart_genesymbol_attribute = 'mgi_symbol', biomart_host="useast.ensembl.org" )
tempoutfile <-file.path(tempdir(), "tpm.csv")
rio::export(tpm, file=tempoutfile)
drop_upload(file=tempoutfile, dest=dropboxfiledir, overwrite=TRUE)
tpm_shared_file <-  drop_share(file.path(dropboxfiledir, "tpm.csv"))$url
```


```{r deseq2-tximport-helper-functions}
# snagged from development version of DESeq
DESeqDataSetFromTximport <- function(txi, colData, design, ...)
{
  counts <- round(txi$counts)
  mode(counts) <- "integer"
  dds <- DESeqDataSetFromMatrix(countData=counts, colData=colData, design=design, ...)
  stopifnot(txi$countsFromAbundance %in% c("no","scaledTPM","lengthScaledTPM"))
  if (txi$countsFromAbundance %in% c("scaledTPM","lengthScaledTPM")) {
    message("using length scaled TPM counts from tximport")
  } else {
    message("using counts and average transcript lengths from tximport")
    lengths <- txi$length
    dimnames(lengths) <- dimnames(dds)
    assays(dds)[["avgTxLength"]] <- lengths
  }
  return(dds)
}

subset_tximport = function(txi, rows, columns) {
    txi$counts = txi$counts[rows, columns]
    txi$abundance = txi$abundance[rows, columns]
    txi$length = txi$length[rows, columns]
    return(txi)
}
```

# ERCC normalization

- what effects does adjusting the counts with the ERCC spikeins have on the data

## RUVSeq adjustment

RUVseq can be used to *Remove Unwanted Variation* from RNA-Seq data. Here, I use the spikeins as control genes in RUVseq's factor analysis to calculate adjustment factors which will be input into the DESeq2 differential analysis regression formula. 

```{r ercc}
library(RUVSeq)
counts = round(data.frame(txi.salmon.all$counts, check.names=FALSE))
counts <- counts[rowSums(counts>0)>1,]
txi.salmon.all = subset_tximport(txi.salmon.all, rownames(counts), colnames(counts))
dds = DESeqDataSetFromTximport(txi.salmon.all, colData=metadata, design=~treatment)

geoMeans = apply(counts, 1, function(row) if (all(row == 0)) 0 else
                 exp(mean(log(row[row != 0]))))
dds = estimateSizeFactors(dds, geoMeans=geoMeans)
dds = DESeq(dds, betaPrior=usebetaprior)

# grab the library size adjusted counts (and round as RUV won't accept non-integer values that aren't log xformed)
norm_counts <- round(counts(dds, normalized=TRUE))
# grab ids of remaining spikein gene
spikes <- row.names(norm_counts)[grepl("ERCC", row.names(norm_counts))]
# run RUVseq using the ERCC spikeins as control genes
ruv <- RUVg(norm_counts, spikes, k=1)
```

## PCA plots
We can take a quick look at the adjusted data from RUVseq by PCA to see if it improves sample clustering. The ERCC spikeins  don't appear to improve the data clustering much, so in the interest of not throwing out variability (adjustments like this can overadjust and hide real variation in addition to technical variation), I didn't make the RUVseq adjustment.

```{r pcaplots}
log_norm_counts = log2(norm_counts + 1)
pc.norm = pca_loadings(log_norm_counts)
comps.norm = data.frame(pc.norm$x)
comps.norm$Name = rownames(comps.norm)
library(dplyr)
comps.norm = comps.norm %>% left_join(summarydata, by=c("Name"="sampleid"))
ggplot(comps.norm, aes(PC1, PC2, color=treatment)) +
    geom_point(size=5) + theme_bw() +
    xlab(paste0("PC1", ": ", round(pc.norm$percentVar[1] * 100), "% variance")) +
    ylab(paste0("PC2", ": ", round(pc.norm$percentVar[2] * 100), "% variance"))+
  ggtitle("Normalized, log transformed data")

log_ruv_counts = log2(ruv$normalizedCounts +1)
pc.ruv = pca_loadings(log_ruv_counts)
comps.ruv = data.frame(pc.ruv$x)
comps.ruv$Name = rownames(comps.ruv)
comps.ruv = comps.ruv %>% left_join(summarydata, by=c("Name"="sampleid"))
ggplot(comps.ruv, aes(PC1, PC2, color=treatment)) +
    geom_point(size=5) + theme_bw() +
    xlab(paste0("PC1", ": ", round(pc.ruv$percentVar[1] * 100), "% variance")) +
    ylab(paste0("PC2", ": ", round(pc.ruv$percentVar[2] * 100), "% variance"))

summarydata <- cbind(summarydata, ruv$W)
```


```{r deseq2-helper-functions}
deseq2resids = function(dds) {
  # calculate residuals for a deseq2 fit
  fitted = t(t(assays(dds)[["mu"]]) / sizeFactors(dds))
  return(counts(dds, normalized=TRUE) - fitted)
}
```

```{r de-setup}
library(DEGreport)
library(vsn)
design = ~treatment
condition = "treatment"
```

# Differential expression

## Pairwise comparisons

- calculating statistics of differential expression for all pairwise comparisons using DESeq2

```{r deseq2-expression-analysis}
# txi.salmon <- txi.salmon.all
counts = round(data.frame(txi.salmon$counts, check.names=FALSE))
counts <- counts[rowSums(counts>0)>1,]
txi.salmon = subset_tximport(txi.salmon, rownames(counts), colnames(counts))
dds = DESeqDataSetFromTximport(txi.salmon, colData=summarydata, design=design)

geoMeans = apply(counts, 1, function(row) if (all(row == 0)) 0 else 
  exp(mean(log(row[row != 0]))))
dds = estimateSizeFactors(dds, geoMeans=geoMeans)
dds = DESeq(dds, betaPrior=usebetaprior)
```

## Effect of variance stabilization

The plots below show the standard deviation of normalized counts (`normalized_counts`) using `log2()`, `rlog()`, and variance stabilizing (`vst()`) transformations by `rank(mean)`. Without such a transformation, discovery of differentially expressed genes can be biased towards highly or lowly expressed genes as the variance changes with  the mean in RNAseq data.  The transformations greatly reduce the standard deviation, with `rlog` stabilizing the variance best across the mean. Therefore, we will use the `rlog` transformed counts for any downstream count visualizations.

```{r deseq-diagnostics, results='asis'}
par(mfrow=c(1,3))
notAllZero <- (rowSums(counts(dds))>0)
rld <- rlog(dds)
vsd <- varianceStabilizingTransformation(dds)
rlogMat <- assay(rld)
vstMat <- assay(vsd)

tempoutfile <-file.path(tempdir(), "rlog.csv")
rio::export(rlogMat, file=tempoutfile)
drop_upload(file=tempoutfile, dest=dropboxfiledir, overwrite=TRUE)
rlog_shared_file <-  drop_share(file.path(dropboxfiledir, "rlog.csv"))$url

meanSdPlot(log2(counts(dds,normalized=TRUE)[notAllZero,] + 1))
meanSdPlot(assay(rld[notAllZero,]))
meanSdPlot(assay(vsd[notAllZero,]))
```

## Dispersion estimates

The following plot shows the dispersion by mean of normalized counts. We expect the dispersion to decrease as the mean of normalized counts increases.

```{r dispersion-estimate}
plotDispEsts(dds)
```

```{r deseq2-handler}
handle_deseq2 = function(dds, summarydata, column) {
  all_combs = combn(levels(summarydata[,column]), 2, simplify=FALSE)
  all_results = list()
  contrast_strings = list()
  for(comb in all_combs) {
    contrast_string = paste(comb, collapse=" vs ")
    contrast = c(column, comb)
    res = results(dds, contrast=contrast)
    if (uselfcshrink){
      res <- lfcShrink(dds, contrast=contrast, res=res)
    }
    res = res[order(res$padj),]
    all_results = c(all_results, res)
    contrast_strings = c(contrast_strings, contrast_string)
  }
  names(all_results) = contrast_strings
  return(all_results)
}
```

## MA-plots

Significant genes are marked in red.

```{r nicer-ma-plot}
plotMA = function(res, contrast_name=NULL) {
  res = data.frame(res)
  res = subset(res, !is.na(padj))
  p = ggplot(res, aes(baseMean, log2FoldChange, color=padj < pvalcutoff)) +
    geom_point(size=0.8) +
    scale_x_log10(
      breaks = scales::trans_breaks("log10", function(x) 10^x),
      labels = scales::trans_format("log10", scales::math_format(10^.x))) +
    annotation_logticks(sides='b') +
    xlab("mean expression across all samples") +
    ylab(expression(log[2]*" fold change")) +
    scale_color_manual(values=c("black", "red", "green")) +
    guides(color=FALSE)
  if(!is.null(contrast_name)) {
    p = p +
      ggtitle(paste("MA-plot for contrast ", contrast_name))
  }
  return(p)
}
```

```{r DESeq-output, results='asis'}
all_results = handle_deseq2(dds, summarydata, condition)
len = length(all_results)
nr = ceiling( len / 3 )
nc = ceiling( len / nr )
par(mfrow=c(nr,nc))

for(i in seq(length(all_results))) {
  res = all_results[[i]]
  ymax = max(res$log2FoldChange, na.rm=TRUE)
  ymin = min(res$log2FoldChange, na.rm=TRUE)
  p <- plotMA(all_results[[i]], names(all_results)[i])
  print(p)
  }
```

## Volcano-plots

Volcano plots are a simple method to visualize the number of significant genes and the relationship between the fold change and pvalue. Here, I plot the adjusted pvalue (for multiple testing) against the log2 fold change. Significant genes (adjusted pvalue<`r pvalcutoff`) are highlighted in green.

```{r DESeq-volcano}
for(i in seq(length(all_results))) {
  print(i)
  stats = as.data.frame(all_results[[i]][,c("log2FoldChange", "padj")])
  p = volcano_density_plot(stats, title=names(all_results)[i], pval.cutoff = pvalcutoff, lfc.cutoff=0)
  print(p)
}
```

## DEGreport

Some simple QC metrics to gauge if anything strange is going on with the differential expression analysis (i.e. bias towards particular gene groups).

```{r get-groups}
get_groups <- function(d, comp, condition)
{
  g <- unlist(strsplit(comp," "))
  g1 <- d$Name[d[, (names(d)==condition)]==g[1]]
  g2 <- d$Name[d[, (names(d)==condition)]==g[3]]
  list(g1,g2)
}
```

### Pvalues-vs-Mean

Here we plot some information about how the p-values are correlated with the mean or the standard deviation.

```{r DEGreport-M}
plots = list()
scale_factor = round(1/nr * 14)
for(i in seq(length(all_results))) {
  plots[[i]] = degMean(all_results[[i]]$pvalue, rlogMat) +
  theme_bw(base_size = scale_factor) +
  ggtitle(paste0("Pvalues-vs-Mean for ", names(all_results)[i]))
}
do.call(grid.arrange,plots)
```

### Pvalues-vs-Variation

```{r DEGreport-V}
plots = list()
for(i in seq(length(all_results))) {
  plots[[i]] = degVar(all_results[[i]]$pvalue, rlogMat) +
  theme_bw(base_size = scale_factor) +
  ggtitle(paste0("Pvalues-vs-Variation for ", names(all_results)[i]))
}
do.call(grid.arrange,plots)
```

## Differentially expressed genes

See the [Downloads](@downloads) section for Excel files with statistics for all genes (which can be filtered to generate the following tables), not just those with significant results.

### Lowest adjusted p-value hits tables

These are just the top 25 significant genes (some comparisons have less) as sorted by pvalue to give you an idea of what's differentially expressed (DE). See the files in the [Downloads](@downloads) section for a file that you can filter (by the adjusted pvalue "padj"<`r pvalcutoff`) to get the full list of DE genes. 


```{r DESeq-tables, cache=FALSE, results='asis'}
for(i in seq(length(all_results))) {
  cat(paste("####", names(all_results)[i]))
  cat("\n\n")
  out_df = as.data.frame(all_results[[i]])
  out_df$id = rownames(out_df)
  out_df = out_df[, c("id", colnames(out_df)[colnames(out_df) != "id"])]
  sig_genes = subset(out_df, padj < pvalcutoff)
  cat(paste("**There are ", nrow(sig_genes), " significant (padj<", pvalcutoff,") genes**\n\n", sep=""))
  if(nrow(sig_genes)>0){
    if(nrow(sig_genes)>50){
      sig_genes <- sig_genes[1:25,]
    }  
    sig_genes <- annotate_df2(sig_genes, "id")
    print(knitr::kable(sig_genes))
  }else{
    cat("**No significant genes**")
  }  
  cat("\n")
}

```

### Lowest adjusted p-value heatmaps

- top 50 significant genes as sorted by adjusted pvalue

```{r deseq2heatmaps , results="asis", fig.height=8}
library(pheatmap)
for(i in seq(length(all_results))) {
  cat(paste("####", names(all_results)[i]))
  out_df = as.data.frame(all_results[[i]])
  out_df$id = rownames(out_df)
  out_df = out_df[, c("id", colnames(out_df)[colnames(out_df) != "id"])]
  sig_genes = subset(out_df, padj < pvalcutoff)
  sig_genes <- sig_genes[order(sig_genes$padj),]
  if(nrow(sig_genes)>0){
    if(nrow(sig_genes)>50){
      sig_genes <- sig_genes[1:50,]
    }
    sig_genes <- annotate_df2(sig_genes, "id")
    sig_gene_ids <- sig_genes$id
    sig_gene_counts <- rlogMat[sig_gene_ids,]
    myrowlabels <- sig_genes$hgnc_symbol
    indexer <- (is.na(myrowlabels)|myrowlabels=="")
    myrowlabels <- ifelse(indexer, sig_genes$id, sig_genes$hgnc_symbol)
    pheatmap(sig_gene_counts, cluster_cols =FALSE, labels_row = myrowlabels, annotation_col = metadata[,"treatment", drop=FALSE], cell_height=1, fontsize_row = 8, scale="row")
  
  }else{
    cat("**No significant genes**")
  }  
  cat("\n")
}
```


### Individual Gene plots
- plots of expression of top `r numgenesplotted` individual genes for comparisons

```{r individualgenes}
for(i in seq(length(all_results))){
  cat(paste(names(all_results)[i]))
  res <- all_results[[i]]
  res <- res[order(res$padj),]
  degPlot(dds, res=all_results[[i]], n=numgenesplotted, xs="treatment", group="treatment")
}
```

---

## Enucleated versus Nucleated without Nuclear background differences

A - Compare Enucleated to Nucleated (will contain nuclear genes and genes that affect nucleation)  
B - Compare Nucleated to Nucleii  (will contain nuclear genes)  
C - Find differences between A and B (to find genes that affect nucleation)  

```{r interaction_setup}
counts = round(data.frame(txi.salmon$counts, check.names=FALSE))
counts <- counts[rowSums(counts>0)>1,]
txi.salmon = subset_tximport(txi.salmon, rownames(counts), colnames(counts))

dds = DESeqDataSetFromTximport(txi.salmon, colData=summarydata, design=~treatment)

geoMeans = apply(counts, 1, function(row) if (all(row == 0)) 0 else 
  exp(mean(log(row[row != 0]))))
dds = estimateSizeFactors(dds, geoMeans=geoMeans)
dds$treatment <- relevel(dds$treatment, ref="nucleated")

dds = DESeq(dds, betaPrior=FALSE)

res <- results(dds, contrast=list(c("treatment_enucleate_vs_nucleated", "treatment_nuclei_vs_nucleated")))

res <- res[order(res$padj),]
```

### Lowest adjusted p-value hits table

These are just the top 25 significant genes (some comparisons have less) as sorted by pvalue to give you an idea of what's differentially expressed (DE). See the files in the [Downloads](@downloads) section for a file that you can filter (by the adjusted pvalue "padj"<`r pvalcutoff`) to get the full list of DE genes. 


```{r diffdiff-tables, cache=FALSE, results='asis'}
out_df = res
out_df <- as.data.frame(out_df)
out_df$id = rownames(out_df)
out_df = out_df[, c("id", colnames(out_df)[colnames(out_df) != "id"])]
sig_genes = subset(out_df, padj < pvalcutoff)
cat(paste("**There are ", nrow(sig_genes), " significant (padj<", pvalcutoff,") genes**\n\n", sep=""))
if(nrow(sig_genes)>0){
  if(nrow(sig_genes)>50){
    sig_genes <- sig_genes[1:25,]
  }  
  sig_genes <- annotate_df2(sig_genes, "id")
  print(knitr::kable(sig_genes))
}else{
  cat("**No significant genes**")
}  
cat("\n")
```


### Lowest adjust p-value heatmap

- top 50 significant genes as sorted by adjusted pvalue

```{r diffdiffheatmaps , results="asis", fig.height=8}

out_df = res
out_df <- as.data.frame(out_df)
out_df$id = rownames(out_df)
out_df = out_df[, c("id", colnames(out_df)[colnames(out_df) != "id"])]
sig_genes = subset(out_df, padj < pvalcutoff)
sig_genes <- sig_genes[order(sig_genes$padj),]
if(nrow(sig_genes)>0){
  if(nrow(sig_genes)>50){
    sig_genes <- sig_genes[1:50,]
  }
  sig_genes <- annotate_df2(sig_genes, "id")
  sig_gene_ids <- sig_genes$id
  sig_gene_counts <- rlogMat[sig_gene_ids,]
  myrowlabels <- sig_genes$hgnc_symbol
  indexer <- (is.na(myrowlabels)|myrowlabels=="")
  myrowlabels <- ifelse(indexer, sig_genes$id, sig_genes$hgnc_symbol)
  pheatmap(sig_gene_counts, cluster_cols =FALSE, labels_row = myrowlabels, annotation_col = metadata[,"treatment", drop=FALSE], cell_height=1, fontsize_row = 8, scale="row")
}else{
  cat("**No significant genes**")
}  
cat("\n")
```

### Individual gene plots

```{r diffdiffindgenes}
res <- res[order(res$padj),]
degPlot(dds, res=res, n=7, xs="treatment", group="treatment")
```

# Downloads {#downloads}

## Gene counts

[Raw counts](`r rawcounts_shared_file`)

These are the raw counts with the ribosomal and mitochondrial genes removed and including the ERCC spikeins. You can use these to repeat this differential expression analysis.

[TPM matrix](`r tpm_shared_file`) 

We recommend reporting these instead of RPKM values, as they make it easier to compare between samples, see [this post](http://www.rna-seqblog.com/rpkm-fpkm-and-tpm-clearly-explained/) for more in-depth reason why. Note that these values are not normalized by the ERCC spikeins, but are just normalized as normal on a library size basis. You can use these to look at the expression of individual genes (i.e. plots of expression levels of individual genes)

[Rlog transformed values](`r rlog_shared_file`)

RNAseq data has a known mean variance relationship such that genes with lower expression values show higher amounts of variance. If you use the normalized RNAseq data for clustering analyses such as PCA or heatmaps, your signal may be biased towards these genes. Performing an rlog transformation on the data removes (mostly) this mean variance relationship, allowing an unbiased look at the data. So we recommend using these values for any such clustering analysis.

## Statistics

```{r DESeq_stats, cache=FALSE, results="hide"}
for(i in seq(length(all_results))) {
  out_df = as.data.frame(all_results[[i]])
  out_df$id = rownames(out_df)
  out_df = out_df[, c("id", colnames(out_df)[colnames(out_df) != "id"])]
  out_df <- annotate_df2(out_df, "id")
  contrast_id <- names(all_results)[i]
  tempoutfile <-file.path(tempdir(), paste("stats_for", contrast_id, "xlsx", sep="."))
  rio::export(out_df, file=tempoutfile)
  rdrop2::drop_upload(file=tempoutfile, dest=dropboxfiledir, overwrite=TRUE)
  assign(paste("stats_", contrast_id, sep=""), rdrop2::drop_share(file.path(dropboxfiledir, paste("stats_for", contrast_id, "xlsx", sep=".")))$url)
}
# for difference of differences
tempoutfile <-file.path(tempdir(), paste("stats_for_enucleated_vs_nucleated_without_nuclei", "xlsx", sep="."))
rio::export(out_df, file=tempoutfile)
rdrop2::drop_upload(file=tempoutfile, dest=dropboxfiledir, overwrite=TRUE)
assign("stats_enucleated_vs_nucleated_without_nuclei", rdrop2::drop_share(file.path(dropboxfiledir, paste("stats_for_enucleated_vs_nucleated_without_nuclei", "xlsx", sep=".")))$url)
```

```{r deseq_stats_file_links, cache=FALSE, results='asis'}
for(i in seq(length(all_results))){
    contrast_id <- names(all_results)[i]

  cat(paste("[**Statistics for ", contrast_id, "**](", get(paste("stats_", contrast_id,sep="")), ")", sep=""))
  cat("  ")
  cat("\n\n")
}
```

[**Statistics for Enucleated versus Nucleated without Nuclear background differences**](stats_enucleated_vs_nucleated_without_nuclei)

---

# SessionInfo

```{r sessioninfo}
sessionInfo()
```

---


# References
